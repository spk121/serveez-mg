\input texinfo
@c %**start of header
@setfilename serveez.info
@settitle Serveez-MG Documentation
@c %** end of header

@include version.texi


@copying
This manual is for Serveez-MG @value{VERSION}.

Copyright @copyright{} 2010, 2011 Michael Gran <spk121@@yahoo.com>@*
Copyright @copyright{} 2000, 2001, 2002 Stefan Jahn <stefan@@lkcc.org>@*
Copyright @copyright{} 2000, 2001, 2002 Raimund Jacob <raimi@@lkcc.org>@*
Copyright @copyright{} 1999 Martin Grabmueller <mgrabmue@@cs.tu-berlin.de>@*

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1
or any later version published by the Free Software Foundation.
A copy of the license is included in the section entitled "GNU
Free Documentation License".
@end quotation
@end copying

@titlepage
@title Serveez-MG, version @value{VERSION}
@subtitle A Guile-friendly server framework
@subtitle Edition @value{EDITION},  @value{UPDATED}
@author Michael Gran
@author Stefan Jahn
@author Raimund Jacob

@page
@vskip 0pt plus 1filll
@insertcopying

@end titlepage

@contents

@ifnottex
@node Top, Preface, (dir), (dir)
@top Serveez-MG

This manual is for Serveez-MG, version @value{VERSION}
@end ifnottex

@menu
* Preface::                     
* Introduction::                
* Installation::                
* Running and Managing::        
* An example Guile server::     
* Deploying::                   
* Concept::                     
* Server::                      
* Coserver::                    
* Bibliography::                
* License::                     

@detailmenu
 --- The Detailed Node Listing ---

An example Guile server

* The HELLO protocol::          
* The hello world server::      

The ``hello world'' server

* The callback functions::      

Command line options

* Serveez Configuration Concepts::  
* Configuring the HTTP Server::  
* Setup the Control Protocol Server::  

Serveez Configuration Concepts

* Define ports::                Port configuration definition
* Define servers::              Server definition
* Bind servers to ports::       How to bind servers to port configurations

Server

* Introduction to servers::     Protocol servers in Serveez
* Writing servers::             How to write Internet protocol servers
* Configuring servers::         How do I configure an existing server ?

Writing servers in Guile

* Guile servers::               Servers using Serveez's guile interface

Coserver

* What are coservers::          The use of coservers in Serveez
* Existing coservers::          What kind of coservers already exist ?

@end detailmenu
@end menu

@node Preface, Introduction, Top, Top
@chapter Preface
There was once a great server framework named GNU Serveez.  It was
basically a tutorial on how to implement an IP-based server as well as
a library and a framework to help you get things done.  It was
amazing: it supported dozens of platforms and many different ways of
serving content over the 'nets.

The code for it is still around, of course, on the GNU website, but,
the project appears to be dead, or mostly dead anyway.

Anyone that decided to pick up and update GNU Serveez would have a
Promethean task: with all those many operating systems laboriously
supported and with all those special cases for various libraries, it
would be a trial just to keep it from bitrotting.  It might actually
be impossible to keep it up to date without a huge community behind
it.  But it never really got that huge community it deserved.

When I (Mike Gran) wanted to make a Guile webservice, I decided to dust
GNU Serveez off and make it work for me, on my one specific platform.
Serveez has built-in support for the Guile dialect of Scheme, which
makes it rather unique.  It is also unmaintained GNU code, which makes
me sad.

For now I call it ``Serveez-MG'' because the code is mostly GNU
Serveez, but, this is really a fork of the true GNU Serveez.  Don't
confuse the two.  This port is targeted to only work on my machines,
and it only implements a handful of the servers that GNU Serveez does.
As a one person project, I needed to strip it down to something I
could understand.

@node Introduction, Installation, Preface, Top
@chapter Introduction

One function of Serveez-MG is as a web server.  It listens for HTTP
requests and then acts on them.  That part of it is boring.  In fact,
right now, is isn't a very modern webserver, since it requires
scripts to be in the @code{cgi-bin} directory.  This may soon change.

The other function of Serveez-MG is to provide a platform for
programming webservices in Guile.  It helps you write a webservice by
implementing a callback and event based server that will call your Guile
routines.  You won't have to worry about writing your own main poll or
select loop.

@node Installation, Running and Managing, Introduction, Top
@chapter Installation

You can skip this section if you are familiar with the GNU'ish way of 
configuring, compiling and installing a GNU package.

@section Install Dependencies

This program depends on other programs that depend on other programs.
Yadda yadda yadda.  It is ``turtles all the way down.''

The most important dependencies are

@itemize @bullet
@item
GNU Make for the building
@item
Guile 2.0 for the Scheme interpreter
@item
libcrypt for some trivial use of encryption
@item
libdl for some dynamic loading action
@end itemize

Of the four, only Guile 2.0 is uncommon and is not part of the Linux
Standards Base.  It, in turn, depends on @file{libunistring}, which is
also uncommon.

@section Getting Serveez-MG
Serveez-MG can be found on
@uref{http://github.com/spk121/serveez-mg}.  It might just be in a Git
repo, or there might be a download in the Download's directory.

@section Building and Installation
If you're building this from the source code, then you will find a
file named 'INSTALL' in the source code package.  It has helpful
information on getting Serveez-MG to compile.  But, compiling from
source is a trial for the unfamiliar.  Maybe someday some GNU or Linux
distribution will package this, but, probably not.

@section Testing
Once the code is all built, you should run its built-in test to see if
it is working by calling @code{make check}.  This check is not
comprehensive, but, does indicate that *something* is at least sort of
working.

@node Running and Managing, An example Guile server, Installation, Top
@chapter Running and Managing

Before you can run Serveez-MG, you need to configure it for your
situation.  Serveez-MG is configured by writing a configuration file,
named @file{serveez.cfg} in Scheme that gets read by Serveez-MG on
startup.

In this chapter, I'm going to explain the format for the configuration
file and all its options.  It is all based on the Scheme language, so
if you don't know Scheme, you might want to learn.  All the kids are
using it these days, if your definition of  ``kids'' is academics,
GNU enthusiasts, and fans of parentheses.

@section Configuration is Code

This configuration file, @file{serveez.cfg}, is actually a program in
the Scheme language.  Serveez-MG kicks off its Scheme interpreter when
it starts up.  It then adds several Serveez-specific procedures to the
Scheme interpreter: there are functions to define ports and servers,
and other networking functions that aren't normally available when
Guile starts up.  After this, it tries to run @file{serveez.cfg}.

Since the configuration is code, you could put anything you liked in
there.  You could make you configuration file delete all the files on
your hard drive if you wished, though this is not recommended.  So
note that there is great versatility and great security risk to this.

@section Trying Serveez

Just to keep you from getting bored, let's run Serveez now before we
dive into the complexities of the configuration file.

First, well add a minimal @file{serveez.cfg} configuration file.

@example
(serveez-verbosity 2)

(define-port! 'http-port '(
                           ("proto"  . "tcp")
                           ("port"   . 10080)
                           ("ipaddr" . "*")))

(define-server! 'http-server '(
              ;; standard properties
              ("admin"        . "nobody@@gmail.com")
              ("host"         . "yourdomain.net")
              ("logfile"      . "http-access.log")
              ("logformat"    . "%h %i %u [%t] \"%R\" %c %l")
              ("docs"         . ".")
              ("type-file"    . "/etc/mime.types")
            ))

(bind-server! 'http-port 'http-server)
@end example

You'll also need to put an html file in this directory.  If you don't
have one, you can use this one: @file{hello.html}

@example
<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <title>Blammo!</title>
 </head>
 <body>
  <h1>Blammo is the word</h1>
 </body>
</html>
@end example

You can kick off the server by typing @code{serveez} on the command
line.  In this state, it will run in the foreground.

You then should be able to point your web browser to
@code{http://localhost:10080/hello.html}.

Once you are done messing about, you can kill the webserver with
@key{CTRL-C}.  It should have generated a @file{http-access.log}
file, which you can now peruse.


@node  An example Guile server, Deploying, Running and Managing, Top
@chapter An example Guile server

But, like I said, the @code{http} server is not that special.  Now I'll
give a description of the ``hello world'' of Guile webservices.  If you
have actually read this document from the beginning, you won't
understand the specifics of the commands; but, I find that it is easier
to scan this example, and then look at the specifics, and then re-read
the example, then it is to wade through reference material with no frame
of reference.

Now we'll describe an example server written in Guile.  The ``hello
world'' server.

@menu
* The HELLO protocol::          
* The hello world server::      
@end menu

@node The HELLO protocol, The hello world server, An example Guile server, An example Guile server
@section The ``hello'' protocol

The first step in making our server is to define a protocol.  The
``hello world'' server's protocol will be very simple.

First, when a client connects to the server, it needs to identify itself
by sending the ASCII string ``HELLO''.

The server will respond by sending the string ``HELLO, WORLD!''

Then, if the client sends the ASCII string ``WHAT TIME IS IT?'', the server
will respond with an ASCII string representation of the time.

If the client sends any other data than that string, the server will
respond with the ASCII string ``ERROR''.

@node  The hello world server,  , The HELLO protocol, An example Guile server
@section The ``hello world'' server

The ``hello world'' server is an Internet server completely written in
Guile with the help of the API provided by the underlying Serveez
application.  The reader will not see any occurrence of the networking
API of Guile.

This server is going to be a TCP server assigned to port 3003.

For the purposes of this example, imagine that all the following code
is in a file named @code{serveez.cfg}.

@menu
* The callback functions::      
@end menu

@node The callback functions,  , The hello world server, The hello world server
@subsection The callback functions

The first callback that needs to be defined in the @code{detect-proto}
callback.  It will scan for the client's initial string ``HELLO'', which
is how the client identifies that it is trying to communicate to the
hello world server.  

For TCP and PIPE servers this step is mandatory since there can be
multiple servers of different protocols listening to the same socket.

First, we need a couple of libraries
@lisp
(use-modules (rnrs bytevectors)
	     (serveez-mg lib))
@end lisp

The @code{detect-proto} callback goes something like this:

@lisp
;; The protocol detection function: this function is called the 
;; first time a client connects.  The client is expected to
;; identify itself by sending the string "HELLO".
(define (hello-detect-proto server socket)
  (let ((input-bytes (svz:sock:receive-buffer socket)))

    (if (bytevector-contains (svz:sock:receive-buffer socket) 
			     (string->utf8 "HELLO"))
	;; If true, allow connection
        1
	;; Otherwise, ignore
	0)))
@end lisp  

When the client connects to the server, whatever
it has sent is stored in the @emph{receive buffer}.  The procedure
@code{svz:sock:receive-buffer} returns a bytevector containing
everything received so far from the client.  Note that this procedure
does not then erase the data from the receive buffer.

Next, we need the 'connect-socket' callback.  This is called once per
connection that has a valid protocol.  This procedure is used to set up
the socket and then connect a request handler to it.

@lisp
;; The connect socket function: after a client has been detected by
;; detect-proto, this function handles each request
(define (hello-connect-socket server socket)
  ;; Each packet is going to be delimited by CR/LF
  (svz:sock:boundary socket "\r\n")
  ;; Connect to the request handler
  (svz:sock:handle-request socket hello-handle-request)
  ;; Zero indicates success
  0)
@end lisp

This procedure tells the socket to chop input data into packets
delimited by the carriage-return / linefeed pair.  Each set of
input that ends with CR/LF will be considered its own packet and will be
processed as a single request.

Then, it connects the procedure @code{hello-handle-request} to the
socket as its request handler.  It will get called once per packet.  So
now, of course, we need a request handler.

@lisp
;; The request handler.
;; If it receives "HELLO", return "HELLO, WORLD!".
;; If it receives "WHAT TIME IT IS?", return the time.
;; Otherwise, return ERROR.
(define (hello-handle-request socket request len)
  (let ((command (strip-boundary (utf8->string request))))
    (cond
     ((string=? command "HELLO")
      (svz:sock:print socket "HELLO, WORLD!\r\n"))
     ((string=? command "WHAT TIME IS IT?")
      (svz:sock:print socket (strftime "%c" (localtime (current-time))))
      (svz:sock:print socket "\r\n"))
     (else
      (svz:sock:print socket "ERROR\r\n")))
    ;; Return zero to indicate success
    0))

(define (strip-boundary str)
  (string-trim-right str (string->char-set "\r\n")))
@end lisp

This request handler does all the heavy lifting.  If it receives
a ``HELLO'' or ``WHAT TIME IS IT?'' command, it will respond
appropriately. 

Now that the callbacks are out of the way, we need to create the port
and server.  The port is a TCP port on port number 3003.

@lisp
;; Port configuration
(define-port! 'hello-port '((proto . tcp)
			    (port . 3003))
@end lisp

The hello server is defined and the callbacks are connect to it like so:

@lisp
(define-servertype! 
  '((prefix  . "hello")
    (description . "guile hello world server")
    (detect-proto . hello-detect-proto)
    (connect-socket . hello-connect-socket)
    (configuration . ())
    ))
@end lisp

The prefix is used to create a name for the new server type: the
@code{hello-server}.  Then its two main callbacks,
@code{hello-detect-proto} and @code{hello-connect-socket}, are connected
to this server type.  The @code{hello-handle-request} callback is not
mentioned here because it needs to be connected to a socket once it has
been opened.  That is why it is connected to a socket in the
@code{hello-connect-socket} callback routine.

Lastly, an instance of the server is created and bound to the port.

@lisp
;; Server instantiation
(define-server! 'hello-server '())

(bind-server! 'hello-port 'hello-server)
@end lisp

With all this in place, running @code{serveez} like so

@example
serveez
@end example

should start up the server.  If your @code{serveez.cfg} file isn't in
this directory, you'll have to call @code{serveez -f
<path>/serveez.cfg}.

We used CR/LF as packet boundaries, which means that we can test this
using a telnet program.  If you telnet to port 3003, you should be able
to type in the commands @code{HELLO} and @code{WHAT TIME IS IT?} and see
the response from the server.

@node Deploying, Concept, An example Guile server, Top
@chapter Deploying

When Serveez-MG is started it reads its configuration from a file
called @file{serveez.cfg} in the current directory and runs the server
loop afterwards. Press @key{^C} to abort the execution of this
program.  Serveez-MG is not interactive and does not automatically
detach from the terminal.

@section Command line options

@table @code
@item -h, --help
Display this help and exit.
@item -V, --version
Display version information and exit.
@item -i, --iflist
List local network interfaces and exit.
@item -f, --cfg-file=FILENAME
File to use as configuration file (serveez.cfg).
@item -v, --verbose=LEVEL
Set level of logging verbosity.
@item -l, --log-file=FILENAME
Use @code{FILENAME} for logging (default is stderr).
@item -P, --password=STRING
Set the password for control connections.
@item -m, --max-sockets=COUNT
Set the maximum number of socket descriptors.
@item -d, --daemon
Start as daemon in background.
@item -c, --stdin
Use standard input as configuration file.
@end table

@menu
* Serveez Configuration Concepts::  
* Configuring the HTTP Server::  
* Setup the Control Protocol Server::  
@end menu

@node Serveez Configuration Concepts, Configuring the HTTP Server, Deploying, Deploying
@section Serveez Configuration Concepts

As noted above Serveez is configured via a configuration file which is
by default @file{serveez.cfg} and can be set by passing the @samp{-f}
command line argument.  When you pipe a file into Serveez or pass the
@samp{-c} argument on the command line the input stream will be used
as configuration file no matter whether you passed a @samp{-f} command
line switch or not.

The idea of the configuration file is this: Serveez starts, the
configuration file (which is Scheme code) is run, and then it enters its
main loop and waits for connections.  If your configuration file
contained Serveez commands to set up the http server to create a Guile
webservice, then they will be available.  If your configuration file
does neither of those things, Serveez will have no servers available.

There are three things you have to do in the configuration file to make
a server available:

@itemize @bullet
@item
define your ports
@item
define your servers
@item
and, bind your servers to the ports
@end itemize

In the next three sections, this process will be described in a
general sense.  Afterwards, we'll describe specifically how to set up
the webserver and the control server.

@menu
* Define ports::                Port configuration definition
* Define servers::              Server definition
* Bind servers to ports::       How to bind servers to port configurations
@end menu

@node Define ports, Define servers, Serveez Configuration Concepts, Serveez Configuration Concepts
@subsection Define ports

A @code{port} (in Serveez) is a transport endpoint. You might know them
from other TCP or UDP server applications. For example: web servers
(HTTP) usually listen on TCP port 80. However, there is more than TCP
ports: we have UDP, ICMP and named pipes each with different options to
set. Every port has a unique name you assign to it. The name of the port is
later used to bind servers to it.

The following examples show how you setup different types of port 
configurations. You start to define such a port using the Guile function
@code{(define-port!)}. The first argument to this functions specifies the
name of the port configuration. The remaining argument describes the
port in detail. A definition of the http-port could be like the following.

@example
(define-port! 'http-port '(("proto"  . "tcp")
                           ("port"   . 80)
                           ("ipaddr" . "*")))
@end example

In this example, @code{define-port!} is a command that you are asking
Serveez to do; @code{http-port} is the name you're assigning to the
port you're making. Following that is a list of configuration items
that are being set: the port protocol is set to TCP; the port number
is set to 80, which is customary for the HTTP port, and the port will
accept connections from the whole range of possible IP addresses.

@subsubsection Port configuration items
This table describes each configuration item for a port in Serveez.  Note 
that not each item applies to every kind of port configuration.

@table @code
@item proto (string)
This is the main configuration item for a port configuration setting up the
type of port.  Valid values are @samp{tcp}, @samp{udp}, @samp{icmp}, 
@samp{raw} and @samp{pipe}.  This configuration item decides which of the 
remaining configuration items apply and which do not.

@item port (integer in the range 0..65535)
The @code{port} item determines the network port number on which TCP
and UDP servers will listen.  Thus it does not make sense for ICMP and
named pipes.  If you pass @samp{0} Serveez will determine a free port
in the range between 1 and 65535.  Remember that port numbers below
1024 are privileged ports and only privileged processes, such as those
run as root, can bind to them.

@item recv (string or associative list)
This item describes the receiving (listening) end of a named pipe
connection, i.e. the filename of a fifo node to which a client can
connect by opening it for writing.  Both the @code{recv} and @code{send}
item apply to named pipes only.  The value can either be an associative
list or a simple filename. Using a simple filename leaves additional
options to use default values. They deal mainly with file permissions
and are described below.

@item send (string or associative list)
This item is the sending end of a named pipe connection. It is used to
send data when the receiving (listening) end has detected a connection.
The following table enumerates the additional options you can
setup if you pass an associative list and not a simple filename.

@table @code
@item name (string)
The filename of the named pipe.

@item permission (octal integer)
This specifies the file permissions a named pipe should be created with.
The given number is interpreted in a Unix'ish style (e.g. @samp{#o0666}
is a permission field for reading and writing for the creating user, all
users in the same group and all other users).

@item user (string)
The file owner (username) of the named pipe in textual form.

@item group (string)
The file owner group (groupname) of the named pipe in textual form.  If
this item is left it defaults to the file owner's primary group.

@item uid (integer)
The file owner of the named pipe as a user id.  You are meant to specify
either the @code{uid} item or the @code{user} item.  Serveez will
complain about conflicting values.

@item gid (integer)
The file owner group of the named pipe as a group id.  This item
defaults to the file owner's primary group id.  You are meant to specify
either the @code{gid} item or the @code{group} item.  Serveez will croak
about conflicting values.
@end table

@item ipaddr (string)
This configuration item specifies the IP address (either in dotted decimal
form e.g. @samp{192.168.2.1} or as a device description which can be
obtained via @samp{serveez -i}) to which a server is bound to.  The 
@samp{*} keyword for all known IP addresses and the @samp{any} keyword for 
any IP address are also valid values.  The default value is @samp{*}.  The
configuration item applies to network ports (TCP, UDP and ICMP) only.

@item device (string)
The @code{device} configuration item also refers to the IP address a server
can be bound to.  It overrides the @code{ipaddr} item.  Valid values are
network device descriptions (probably no aliases and no loopback devices).
It applies to network ports (TCP, UDP and ICMP) only.

@item backlog (integer)
The @code{backlog} parameter defines the maximum length the queue of 
pending connections may grow to.  If a connection request arrives with the 
queue full the client may receive an error.  This parameter applies to
TCP ports only.

@item type (integer in the range 0..255)
This item applies to ICMP ports only.  It defines the message type 
identifier used to send ICMP packets (e.g. @samp{8} is an echo message 
i.e. PING).

@item send-buffer-size (integer)
The @code{send-buffer-size} configuration item defines the maximum number 
of bytes the send queue of a client is allowed to grow to.  The item 
influences the "send buffer overrun error condition".  For packet oriented
protocols (UDP and ICMP) you need to specify at least the maximum number
of bytes a single packets can have.  For UDP and ICMP this is 64 KByte.
The value specified here is an initial value. It is used unless the
server bound to this port changes it.

@item recv-buffer-size (integer)
The @code{recv-buffer-size} configuration item defines the maximum
number of bytes the receive queue of a client is allowed to grow to.
The item influences the "receive buffer underrun error condition".  The
value specified here is an initial value. It is used unless the server
bound to this port changes it.

@item connect-frequency (integer)
This item determines the maximum number of connections per second the port 
will accept.  It is a kind of "hammer protection".  The item is evaluated
for each remote client machine separately.  It applies to TCP ports.

@item allow (list of strings)
Both the @code{allow} and @code{deny} lists are lists of IP addresses in 
dotted decimal form (e.g. @samp{192.168.2.1}). The @code{allow} list defines
the remote machines which are allowed to connect to the port.  It applies
to TCP ports.

@item deny (list of strings)
The @code{deny} list defines the remote machines which are not allowed to 
connect to the port.  Each connection from one of these IP addresses will
be refused and shut down immediately.  It applies to TCP ports.
@end table

@subsubsection TCP port definition
As another example, here is a definition of a TCP port configuration
with the name "foo-tcp-port". The enhanced settings are all optional
including the @var{ipaddr} property which defaults to @samp{*}. The
@var{ipaddr} item can contain any form of a dotted decimal internet
address, a @samp{*}, @samp{any} or an interface description which you
can obtain by running @samp{serveez -i}.

@example
(define-port! 'foo-tcp-port '(
    ;; usual settings
    (proto  . tcp)              ;; protocol is tcp
    (port   . 42421)            ;; network port 42421
    (ipaddr . *)                ;; bind to all known interfaces
    (device . eth0)             ;; bind to network card

    ;; enhanced settings
    (backlog           . 5)     ;; enqueue max. 5 connections
    (connect-frequency . 1)     ;; allow 1 connect per second
    (send-buffer-size  . 1024)  ;; initial send buffer size in bytes
    (recv-buffer-size  . 1024)  ;; initial receive buffer size in bytes

    ;; allow connections from these ip addresses
    (allow             . (127.0.0.1 127.0.0.2))

    ;; refuse connections from this ip address
    (deny              . (192.168.2.7))
  ))
@end example

@subsubsection Pipe port definition
Definition of a pipe port configuration with the name "foo-pipe-port".
When bound to a server it creates the receiving end and listens on that.
If some client accesses this named pipe the server opens the sending end
which the client has to open for reading previously.

The only mandatory item is the file name of each pipe.  If you want to
specify a user creating the named pipe (file ownership) use either the
@var{user} or the @var{uid} setting.  Same goes for the items
@var{group} and @var{gid}.

@example
(define-port! 'foo-pipe-port `(
    (proto . pipe)                   ;; protocol is named pipe

    ;; specify the receiving endpoint    
    (recv . ((name . ".foo-recv")    ;; name of the pipe
             (permissions . #o0666)  ;; create it with these permissions
             (user . "calvin")       ;; as user "calvin"
             (uid . 50)              ;; with the user id 50
             (group . "heros")       ;; which is in the group "heros"
             (gid . 100)))           ;; with the group id 100

    ;; specify the sending endpoint
    (send . ((name . ".foo-send")
             (permissions . #o0666)
             (user . "hobbes")
             (uid . 51)
             (group . "stuffed")
             (gid . 101)))
   ))
@end example

@subsubsection UDP port definition
Simple definition of a UDP port configuration with the name "foo-udp-port".

@example
(define-port! 'foo-udp-port `((proto . udp)
                              (port  . 27952)))
@end example

@node Define servers, Bind servers to ports, Define ports, Serveez Configuration Concepts
@subsection Define servers

A @code{server} (in Serveez) is code that implements some
protocol. There is an HTTP server built into Serveez -- and a control
server and a 'passthrough' server that we'll describe later -- but you
can implement your own, too. Each server -- either serveez's http
server, passthrough server, or control server or any servers you
implement yourself in Scheme -- has a different set of options you can
change. You can have many instances of every server, each with a
different set of options. For example: You can create a webserver on TCP
port 42420 publishing the Serveez documentation and also have another
webserver on a different port publishing something else. Every server
has a unique name you assign to it. The name of the server is later used
to bind it to a port.

Each type of port will have its own specific list of configuration
parameters.  The HTTP server has a different set of configuration
parameters than another type of server.

The following example instantiates a server with the short name
"foo". This example demonstrates all the different data types that might
appear in server configurations. You start a definition of a server with
the guile function @code{(define-server!)}. The following argument
specifies the name of the server instance (in this case "foo-server")
which starts with the short name. The second argument describes the
server in detail. Each configuration item is setup with a @code{(key
. value)} pair where "key" is the name of the configuration item and
"value" is the value which depends on the type of the
item. @xref{Configuring servers}, for a detailed description of each
type of value.

@example
(define-server! 'foo-server '(
    (bar . 100)                             ;; number
    (reply . "Booo")                        ;; character string
    (messages .                             ;; list of strings
      ("Welcome to the foo test server."
       "This one echos your lines."))
    (ports . (5 6 7 8 9))                   ;; list of numbers
    (port . foo-tcp-port)                   ;; a port configuration
    (assoc . (( "GNU" . "great" )           ;; associative list
              ( "Tree" . "tall" )))
    (truth . #f)                            ;; boolean value
  ))
@end example

@node Bind servers to ports,  , Define servers, Serveez Configuration Concepts
@subsection Bind servers to ports

Finally you can bind servers to ports. When you do so the server you
created listens on the port, accepts connections and serves clients. It
does so as soon as Serveez enters its main loop right after running the
configuration file. Serveez won't stop until you interrupt it (e.g. by
pressing @key{^C} in the terminal you started it in).

This example binds the server "foo-server" (s.a.) to the port "foo-tcp-port"
which was described above. Therefore you need to call the guile function
@code{(bind-server!)} which takes two arguments specifying the name of a port 
configuration and a server instance. Both need to be defined before
you can write this statement.

@example
(bind-server! 'foo-tcp-port 'foo-server)
@end example

One of the main features of Serveez is that you can bind multiple
servers to the same port. This for example is useful to pass braindead
firewall configurations or proxy servers. It is also possible to bind
servers to ports they are actually not designed for. This might be used
for debugging servers or other funny things (again, think about the
firewall). This is the point we have to warn you: Some protocols cannot
share the same port (e.g. the tunnel server) and some protocols simply won't
work on 'wrong' ports. Additionally, you will not get error messages when
that happens. The server just will not work then.

@node Configuring the HTTP Server, Setup the Control Protocol Server, Serveez Configuration Concepts, Deploying
@section Configuring the HTTP Server

The integrated HTTP server was originally meant to be a simple but
fast document server. It can also execute CGI scripts. The GET, HEAD
and POST methods are fully functional. Additionally Serveez produces
directory listings when no standard document file
(e.g. @file{index.html}) has been found at the requested document node
(directory).  Furthermore it implements a file cache for speeding up
repetitive HTTP request.

For now, this HTTP server uses old concepts of web content.  It assumes
that everything that is to be served is either static content like
webpages and images, or is a CGI (Common Gateway Interface) script that
is placed in the CGI directory.  This will change in the future so that
any URI can be used to serve dynamic content, instead of just scripts in
the CGI directory.

The basic setup of the HTTP server requires that the serveez.cfg file
contains something like the following:

@example
(define-port! 'http-port '(
                           ("proto"  . "tcp")
                           ("port"   . 80)
                           ("ipaddr" . "*")))

(define-server! 'http-server '(
              ;; standard properties
              ("admin"        . "nobody@@gmail.com")
              ("host"         . "yourdomain.net")
              ("logfile"      . "http-access.log")
              ("logformat"    . "%h %i %u [%t] \"%R\" %c %l")
              ("indexfile"    . "index.html")
              ("docs"         . "/var/www/html")
              ("userdir"      . "public_html")
              ("type-file"    . "/etc/mime.types")
              ("default-type" . "text/plain")
              ("nslookup"     . on)
              ("ident"        . yes)

              ;; cgi interface
              ("cgi-url"         . "/cgi-bin")
              ("cgi-dir"         . "/var/www/cgi-bin")
              ("cgi-application" . (("pl"  . "perl")
                                    ("py"  . "python")))
            ))

(bind-server! 'http-port 'http-server
@end example

Remember that port numbers below 1024 are privileged ports and only
privileged processes, such as those run as root, can bind to them.


@subsection Configuration

The following options for the HTTP server can be set from the
configuration file.

@table @code
@item indexfile (string, default: index.html)
The @code{indexfile} parameter is the default file served by the HTTP 
server when the user does not specify a file but a document node
(e.g. @uref{http://www.lkcc.org/}).

@item docs (string, default: ../show)
The @code{docs} parameter is the document root where the server finds its
web documents.

@item userdir (string, default: public_html)
Each @samp{~user} request gets converted into the given users home
directory. The string will be appended to this directory. Its default
value is @samp{public_html}.

@item cgi-url (string, default: /cgi-bin)
This parameter is the first part of the URL the HTTP server identifies a
CGI request. For instance if you specify here @file{/cgi-bin} and the
user requests @uref{http://www.lkcc.org/cgi-bin/test.pl} then the
HTTP server tries to execute the program @file{test.pl} within the
@code{cgi-dir} (see below) and pipes its output to the user.

@item cgi-dir (string, default: ./cgibin)
The @code{cgi-dir} is the CGI document root (on the server).

@item cgi-application (hash, default: empty)
You can use this hash to associate certain file suffices with
applications on your computer (e.g. "pl" with "perl").

@item cache-size (integer, default: 200 kb)
This specifies the size of the document cache in bytes for each cache
entry.

@item cache-entries (integer, default: 64)
This parameter specifies the maximum number of HTTP file cache entries
(files). When you instantiate more than one HTTP server the biggest value
wins. The HTTP file cache is shared by all HTTP servers.@*
@strong{Please note}: If your harddrive/filesystem combination proves to 
be faster than the HTTP file cache you should disable it by setting both
@code{cache-size} and @code{cache-entries} to zero.

@item timeout (integer, default: 15)
The @code{timeout} value is the amount of time in seconds after which 
a keep-alive connection (this is a HTTP/1.1 feature) will be closed when
it has been idle.

@item keepalive (integer, default: 10)
On one keep-alive connection can be served the number of @code{keepalive}
documents at all. Then the connection will be closed.
Both this and the @code{timeout} value are just to be on the safe side. 
They protect against idle and high traffic connections.

@item default-type (string, default: text/plain)
The @code{default-type} is the default content type the HTTP server
assumes if it can not identify a served file by the @code{types} hash
and the @code{type-file} (see below).

@item type-file (string, default: /etc/mime.types)
This should be a file like the @file{/etc/mime.types} on Unix systems.
It associates file suffices with MIME types.

@item types (hash, default: empty)
If you want to specify special content types do it here. This parameter
is a hash map associating file suffices with HTTP content types (MIME types).

@item admin (string, default: root@@localhost)
Your address, where problems with the server should be e-mailed.
This address appears on some server-generated pages, such as error
documents.

@item host (string, default: localhost)
This is the native host name of your web server. Sometimes the server has
to send back its own name to the client. It will use this value.
Be aware that you cannot invent such a name.

@item nslookup (boolean, default: false)
If this is true the HTTP server invokes a reverse DNS lookup
for each client connection in order to replace the remote ip address with
the remote host name in the access logfile.

@item ident (boolean, default: false)
If this is true the HTTP server processes identd requests
for each client connection for logging purposes.

@item logfile (string, default: http-access.log)
The location of the access logfile. For each HTTP request a line gets
appended to this file.

@item logformat (string, default: CLF)
The format of the access logfile. There are special placeholders for
different kinds of logging information. The default log format is the
Common Log Format (CLF). It contains a separate line for each request. A 
line is composed of several tokens separated by spaces.
@example
CLF = host ident authuser date request status bytes 
@end example
If a token does not have a value then it is represented by a hyphen (-). 
The meanings and values of these tokens are as follows: 

@table @code
@item %h (host)
The fully-qualified domain name of the client, or its IP number if the name 
is not available.
@item %i (ident)
This is the identity information reported by the client. Not active, so 
we will see a hyphen (-).
@item %u (authuser)
If the request was for an password protected document, then this is the 
userid used in the request. 
@item %t (date)
The date and time of the request, in the following format:
@example
date   = [day/month/year:hour:minute:second zone] 
day    = 2*digit 
month  = 3*letter 
year   = 4*digit 
hour   = 2*digit 
minute = 2*digit 
second = 2*digit 
zone   = (`+' | `-') 4*digit 
@end example
@item %R (request)
The request line from the client, enclosed in double quotes (").
@item %r (referrer)
Which document referred to this document.
@item %a (agent)
What kind of web browser did the remote client use.
@item %c (status)
The three digit status code returned to the client. 
@item %l (bytes)
The number of bytes in the object returned to the client, not including 
any headers. 
@end table
@end table

@node  Setup the Control Protocol Server,  , Configuring the HTTP Server, Deploying
@section Setup the Control Protocol Server

Now that you've added the configuration for the HTTP server to the
@file{serveez.cfg} configuration file, the next step is to set up the
Control Protocol Server, which allows you to do some administration on
the server process without having to stop and restart it.

To this end, Serveez implements something like a telnet protocol for
administrative purposes. You just need to start a telnet session like:
@example
$ telnet www.yourdomain.org 42420
@end example
After pressing @key{RET} you will be asked for a password which you
might setup passing Serveez the -P argument. 

@subsection Configuration of the Control Protocol Server

The control protocol server doesn't have many options to configure.
But, in the @file{serveez.cfg} file, you need to bind it to a TCP
port, like so:

@example
(define-port! 'control-port `(
			      (proto . tcp)
			      (port . 42420)
			      (ipaddr . *)
			      ))

(define-server! 'control-server)

(bind-server! 'control-port 'control-server)
@end example

This example has it bound to port 42420, so you would telnet to that
port.

The password that the Control Protocol Server will expect can be set
in a couple of ways.  It can be specified on the command line when
Serveez is invoked.  It can also be set in the @file{serveez.cfg} file
by using the @code{serveez-passwd} procedure.

@subsection Using the Control Protocol

Once you've connected to the Control Protocl Server via telnet, you'll
be given a prompt at which you can enter the following commands.

@table @samp
@item help
This command will give you a very short help screen of all available
commands.

@item quit
This command closes the connection to Serveez.

@item restart ident
Restarts the internal ident coserver. This is useful if you just want
to start a new one if the old one died or is otherwise unusable.

@item restart dns
Restarts the internal dns lookup server.

@item restart reverse dns
Restarts the internal reverse dns lookup server.

@item killall
This might be useful if Serveez seems to be unstable but you do not
want to restart it. With @samp{killall} you disconnect all client
network connections except the control protocol connections.

@item kill id NUM
Disconnects a specific connection identified by its ID. These IDs will
be stated when you type @samp{stat con} (see below).

@item stat
General statistics about Serveez. This will show you some useful
information about the computer Serveez is running on and about the
state of Serveez in general.

@item stat coserver
Statistics about all running coserver instances.

@item stat SERVER
This command is for selecting certain server instances to be listed.
SERVER is one of server names you specified in the configuration file.

@item stat id NUM
Show statistics about a specific connection. This will give you all
available information about every connection you specified.
@xref{Writing servers}, for more information about how to provide these
information.

@item stat con
Connection statistics. This will give a list of all socket structures
within Serveez. If you want more detailed information about specific
connections, coservers or servers you need to request these information
with @samp{stat id NUM} or @samp{stat all}.

@item stat all
Server and coserver instance statistics. This command lists all
the information about instantiated servers and coservers.
@xref{Writing servers}, for more information about how to provide these
information.

@item stat cache
HTTP cache statistics. This command produces an output something like the 
following where @samp{File} is the short name of the cache entry, 
@samp{Size} the cache size, @samp{Usage} the amount of connections 
currently using this entry, @samp{Hits} the amount of cache hits, 
@samp{Recent} the cache strategy flag (newer entries have larger numbers) 
and @samp{Ready} is the current state of the cache entry.

@example
File                      Size  Usage  Hits Recent Ready
zlib-1.1.3-20000531.zip  45393      0     0      1 Yes
texinfo.tex             200531      0     0      2 Yes
shayne.txt                2534      0     1      1 Yes

Total : 248458 byte in 3 cache entries
@end example

@item kill cache
Reinitialize the HTTP file cache. Flushes all files from the cache.
@end table

@section Additional configuration possibilities

The three functions @code{(define-port!)}, @code{(define-server!)} and
@code{(bind-server!)} return @code{#t} on success and @code{#f} on
failure.  For your convenience we provide some more Guile functions.
Some of these are based upon the above.  You will find the additional
functions in @code{(serveez-mg lib)} library that will be copied into
Guile's site directory.  In order to include this convenience
functionality you can @code{(use-modules (serveez-mg lib))} at the top
of the configuration file.

@table @code
@item (interface-add! . interface)
Add one more network interfaces to the list of known interfaces. You can
get the list of known interfaces by running @samp{serveez -i}. The
@var{interface} argument must be in dotted decimal form
(e.g. 127.0.0.1). Serveez provides this function for systems where it is
unable to detect the list of network interface automatically.

@c @item (loadpath-add! . path)
@c Extends the load path for server modules by the path name @var{path}.

@item (bind-servers! . args)
This function is based upon @code{(bind-server!)}. It takes a list of port
configurations and servers and binds each to another.

@item (bind-tcp-port-range! from to . servers)
Bind the list of @var{servers} to simple TCP port configurations whose network
ports range between @var{from} and @var{to} both inclusive.

@item (bind-udp-port-range! from to . servers)
Bind the list of @var{servers} to simple UDP port configurations whose network
ports range between @var{from} and @var{to} both inclusive.

@item (serveez-verbosity verbosity)
Set the core library's logging verbosity to the @var{verbosity} level. Lesser
values mean fewer logging messages. This settings gets overridden by command
line.

@item (serveez-maxsockets max)
Set the number of maximum socket descriptors (number of concurrent 
connections). When passing Serveez the -m command line argument this setting
gets overridden, too.

@item (serveez-passwd password)
Set the @var{password} for the control protocol.
@end table

@subsection Passthrough Server

Another way to serve information in Serveez-MG is to use the passthrough
server.  The passthrough server lets you take a program that uses
@code{stdin} and @code{stdout} for input and output to server content
over a port.  Serveez-MG translates input and output from a port to the
@code{stdin} and @code{stdout} of the program.  In this way, it
functions like the internet daemon @code{inetd}.

@subsubsection General description
The program passthrough server provides basic inetd functionality.
Basically it can accept connections and pass this connection to the standard
input (stdin) and standard output (stdout) handles of programs.  Depending
on the platform (operating system) the user is able to configure different
methods how this can be achieved.

@subsubsection Configuration
This server has different types of configuration options specifying its
behaviour.  Some of them are mandatory and some are optional.  The very
least to configure is the program to be started when a new connection is
made.

@table @code
@item binary (string, no default)
This parameter specifies the program to execute when a new connection
has been accepted.  The parameter is mandatory and must be a fully qualified
file name (including path).

@item directory (string, no default)
This will be the working directory of the executed program.  If you omit 
this parameter the server uses the current directory (the directory is not 
changed).

@item user (string, no default)
If you omit this parameter no user or group will be set for the 
started program.  Otherwise you need to specify this information in the
format @samp{user[.group]}.  If the group is omitted the user's primary
group will be used.

@item argv (string array, no default)
This list of character strings is going to be the program's argument list
(command line).  If the first list item (which is argv[0] and the program's
name) is left blank it defaults to the name specified in the
@code{binary} parameter.

@item do-fork (boolean, default: true)
This flag specifies the method used to pass the connection to the program.
If it is true the server uses the Unix'ish @code{fork()} and @code{exec()}
method.  Otherwise it will pass the data through a unnamed pair of
sockets [ or two pairs of anonymous pipes ].

@item single-threaded (boolean, default: true)
This parameter applies to servers bound to UDP and ICMP port configurations
only.  For programs which process all incoming packets and eventually time 
out, the program is said to be @samp{single-threaded} and should use a true
value here.  If a program gets a packet and can receive further packets, it 
is said to be a @samp{multi-threaded} program, and should use a false value.

@item thread-frequency (integer, default: 40)
The optional @code{thread-frequency} parameter specifies the maximum number
of program instances that may be spawned from the server within an interval
of 60 seconds.
@end table

@node Concept, Server, Deploying, Top
@chapter Concept

We now have a closer look at the internals of Serveez. You'll need
to understand this is you want to write your own server in Scheme.

@section Overall concept
The primary functionality Serveez provides is a framework for Internet
services.  It can act as a kind of server collection and may even
replace super-servers such as the inetd daemon.

Its key features and benefits are:

@itemize @bullet
@item support for packet and connection oriented protocols@*
Serveez currently supports two server types.  TCP and named pipe servers
are connection oriented servers.  This type of server accepts a client's
connection request and communicates with it using a dedicated
connection.  The format of the incoming and outgoing data streams are
irrelevant to Serveez.  Packet oriented servers (like UDP and ICMP)
receive data packets and respond to the sender with data packets.  A
server in Serveez can detect whether it is bound to a packet or
connection oriented port configuration and thus can act as the expected
type.

@item server and client functionality@*
Besides a wide variety of server capabilities, Serveez also contains
some client functionality.  This may be necessary when a server is meant
to establish a connection to another server in response to an incoming
request.  For example, imagine a protocol where a client tells the
server "Let me be the server.  Please connect to this @var{host} at this
@var{port}.".  You are also able to implement pure clients.

@item complete lack of platform portability@*
The original GNU Serveez was a miracle of platform portability.  This
version, Serveez-MG, is not.  It very specifically targets those
GNU/Linux distributions that are complient with the LSB 4.1
specification.

@item powerful configuration capabilities@*
Server configuration has always been a complicated but very important
issue.  When Serveez starts up it runs the configuration file using the
programming language Guile.  In contradiction, other (server)
applications just read their configuration files and remember the
settings in it.  This makes them powerful enough to adapt the Serveez
settings dynamically.  Using the Guile interpreter also means that you
can split your configuration into separate files and load these, perhaps
conditionally, from the main configuration file.

@item easy server implementation@*
Serveez is a server framework.  When implementing a new server the
programmer need pay little or no attention to the networking code but is
free to direct his attention to the protocol the server is meant to
support.  That protocol may be an established one such as HTTP, or may
be a custom protocol fitting the specific application's requirements.

@item code reusability@*
The GNU Serveez package did come along with a core library and an API
for the C language which contained most of the functionality necessary
to write an Internet server.  Most probably, a programmer could also
use the library for other (network programming related) purposes.
But, for this version, Serveez-MG, I've stripped out some of its
functionality, so the original GNU version might be better if you
actually wanted a core library.

This version does retain the Guile functionality, though.

@item server instantiation and network port sharing@*
Once you have written a protocol server and integrated into Serveez's
concept of servers the user can instantiate (multiply) the server.  At
the first glimpse this sounds silly, but with different server
configurations it does not.  If, for example, an administrator wishes to
run multiple HTTP servers with different document roots, Serveez will
handle them all in a single process.  Also if the same administrator
wants to run a HTTP server and some other server on the same network
port this is possible with Serveez.  You can run a single server on
different network ports, too.
@end itemize

@section I/O Strategy
Serveez-MG's I/O strategy is the traditional @code{poll()} function

@subsection Limits on open filehandles

The limits set by @code{ulimit()} or @code{setrlimit()} affect the
performance of the servers.

@node Server, Coserver, Concept, Top
@chapter Server

@menu
* Introduction to servers::     Protocol servers in Serveez
* Writing servers::             How to write Internet protocol servers
* Configuring servers::         How do I configure an existing server ?
@end menu

@node Introduction to servers, Writing servers, Server, Server
@section Introduction to servers

Serveez is a kind of server server. It allows different protocol
servers to listen on various TCP/UDP ports, on ICMP sockets and on named
pipes. Servers are instantiated with a certain configuration. It is
possible to run multiple different servers on the same port.

This chapter covers all questions about how to write your own Internet
protocol server with this package. Most of the common tasks of
such a server have got a generic solution (default routines) which could be 
"overridden" by your own routines. There are some examples within this 
package. They are showing the possibilities with this package and how to
implement servers.

The @samp{foo} server does not do anything at all and is of no actual use
but could be a basis for a new protocol server. We are now going to describe
how this specific server works. Eventually the reader might get an 
impression of what is going on.

For better understanding the text below we will use the following
terminology:
@table @asis

@item server definition
A server definition is a @code{#<svz-servertype>} which contains
server specific members like its name, different callbacks, a single
default configuration and a list of configuration items which
determines what can be configured.

@item server configuration
A server configuration can be any kind of structure. The default server
configuration must be specified within the server definition (see above).
When instantiating a server (which is done via the configuration file) the
configuration items specified in the server definition get processed and
are put into a copy of the default configuration. Thus we get an instance.

@item server instance
A server instance is a copy of the server definition including the modified
server configuration. A server gets instantiated by the configuration file
parser. The concept of server instances has been introduced because we 
wanted Serveez to have the following features. A single server can have
multiple instances with different behaviour due to different server
configurations. A server instance can be bound to multiple port
configurations. Different server instances (of the same and/or different
server type) can share the same port configuration.
@end table

@node Writing servers, Configuring servers, Introduction to servers, Server
@section Writing servers in Guile

This section describes the Guile interface to Serveez which provides
the ability to write servers with Guile.  Of course, you could do this
without any help from Serveez, but it makes the task a lot easier.
This interface reduces the Guile implementation of an Internet server
to a simple data processor.

@menu
* Guile servers::               Servers using Serveez's guile interface
@end menu

@node Guile servers,  , Writing servers, Writing servers
@subsection Guile server functions reference manual

@include guile-api.texi

@node Configuring servers,  , Writing servers, Server
@section Some words about server configuration

If you define a server you basically pass an instance name and a list of
items to the @code{(define-server!)} function. Each item has a name and a
value. A value has a type. We provide several types: integers (numbers),
integer arrays, strings, string arrays, booleans (yes/no-values), hashes
(associations) and port configurations.

The following table shows how each kind of value is set up in the 
configuration file. @var{item} is the name of the item to be configured.

@table @asis
@item Integer@*
Example: (item . 42)
@item Integer array@*
Example: (item . (0 1 2 3))
@item String@*
Example: (item . "a character string")
@item String array@*
Example: (item . ("abc" "cba" "bca" "acb"))
@item Boolean@*
A normal boolean in guile is represented by #t or #f. But the configuration
file parser additional understand some bare words and numbers.@*
Example: (item . #f)
@item Hash@*
Hash maps associate keys with values. Both must be character strings.@*
Example: (item . (key1 . "value1") (key2 . "value2"))
@item Port configuration@*
@xref{Define ports}, for more information on this. When configuring a port
configuration you need to define it via @code{(define-port!)} previously and
put its symbolic name into the configuration.@*
Example: (item . foo-tcp-port)
@end table


@node Coserver, Bibliography, Server, Top
@chapter Coserver

@menu
* What are coservers::          The use of coservers in Serveez
* Existing coservers::          What kind of coservers already exist ?
@end menu

@node What are coservers, Existing coservers, Coserver, Coserver
@section What are coservers

If it is necessary to complete blocking tasks in Serveez you have to use
coservers.  Serveez comes with three useful coservers.  Using these
coservers keeps a these blocking tasks from hanging the server.

@node Existing coservers,  , What are coservers, Coserver
@section Existing coservers

@subsection Identification (Ident) coserver

The Identification protocol is briefly documented in RFC1413. It
provides a means to determine the identity of a user of a particular 
TCP connection. Given a TCP port number pair, it returns a character 
string which identifies the owner of that connection on the server's
(that is the client's) system.

This is a connection based application on TCP. A server listens for
TCP connections on TCP port 113 (decimal). Once a connection is
established, the server reads a line of data which specifies the
connection of interest. If it exists, the system dependent user
identifier of the connection of interest is sent as the reply. The
server may then either shut down the connection or it may continue to
read/respond to more queries.

The Ident coserver is a client to this kind of service. For every
established network connection you can use this service by calling the
appropriate procedure @code{svz:coserver:ident} with an appropriate
callback function.

@example
(svz:coserver:ident sock my-callback arg)
@end example

In this context @code{sock} is of type @code{#<svz-socket>} and 
@code{my-callback} is something like the following example. @code{arg} is
any Guile value and it gets passed verbatim to the callback procedure.
A simple callback procedure that just prints out the user could look
something like the following.

@lisp    
(define (my-callback user args)
  (format #t "Identified user ~a~%" user))
@end lisp  

@subsection Domain Name Server (DNS) coserver

The DNS coserver uses @code{gethostbyname} to translate a given
hostname to the associated IP address. It is passed a hostname and,
when it has received a response from the Domain Name Server identifying
the hostname, it calls a callback function to return the internet
address corresponding to that hostname.

@example
(svz:coserver:dns "www.gnu.org" coserver-callback args)
@end example

Callback:
@example
(define (coserver-callback ip args)
  (format #t "The ip address is ~a~%" ip))
@end example

@subsection Reverse Domain Name Server (reverse DNS) coserver

As easily guessed from the name this coserver is just doing the reverse
as the DNS coserver. It translates a given IP address into a hostname
using @code{gethostbyaddr}. In the procedure call, the IP address is
given as a positive integer in host byte order. The Reverse DNS coserver
itself takes something like @samp{192.168.2.1}.

@example
(svz:coserver:reverse-dns (inet-pton AF_INET "192.168.1.255") 
  reverse-callback args)
@end example

Callback:
@example
(define (reverse-callback hostname args)
  (format #t "Hostname is ~a~%" hostname))
@end example


@node Bibliography, License, Coserver, Top
@chapter Bibliography

This section contain some of the documents and resources we read and used
to implement various parts of this package. They appear in no specific
order.

@enumerate
@item 
RFC 760@*
The Internet Protocol
@item 
RFC 1071@*
Computing the Internet Checksum
@item 
RFC 1413@*
Identification Protocol
@item 
RFC 1459@*
Internet Relay Chat Protocol
@item 
RFC 1945@*
Hypertext Transfer Protocol -- HTTP/1.0
@item 
RFC 2068@*
Hypertext Transfer Protocol -- HTTP/1.1
@item 
RFC 2616@*
Hypertext Transfer Protocol -- HTTP/1.1
@item 
RFC 768@*
User Datagram Protocol
@item 
RFC 791@*
Internet Protocol
@end enumerate

@node License,  , Bibliography, Top
@chapter License

GNU General Public License Version 2, June 1991@*

Serveez is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or any later version.

This software is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this package; see the file COPYING.  If not, write to
the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.

@*
Copyright @copyright{} 2010, 2011 Michael Gran <spk121@@yahoo.com>@*
Copyright @copyright{} 1999, 2000, 2001, 2002 Martin Grabmueller <mgrabmue@@cs.tu-berlin.de>@*
Copyright @copyright{} 2000, 2001, 2002 Raimund Jacob <raimi@@lkcc.org>@*
Copyright @copyright{} 2000, 2001, 2002, 2003, 2004 Stefan Jahn <stefan@@lkcc.org>@*

Verbatim copying and distribution of this entire document is
permitted in any medium, provided this notice is preserved.

@contents
@bye
