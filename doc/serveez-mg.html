<html lang="en">
<head>
<title>Serveez-MG Documentation</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Serveez-MG Documentation">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This manual is for Serveez-MG 0.2.

Copyright (C) 2010, 2011 Michael Gran <spk121@yahoo.com>

Copyright (C) 2000, 2001, 2002 Stefan Jahn <stefan@lkcc.org>

Copyright (C) 2000, 2001, 2002 Raimund Jacob <raimi@lkcc.org>

Copyright (C) 1999 Martin Grabmueller <mgrabmue@cs.tu-berlin.de>


     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.1 or any later version published by the Free Software
     Foundation.  A copy of the license is included in the section
     entitled "GNU Free Documentation License".
-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<h1 class="settitle">Serveez-MG Documentation</h1>
   <div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Top" href="#Top">Serveez-MG</a>
<li><a name="toc_Preface" href="#Preface">1 Preface</a>
<li><a name="toc_Introduction" href="#Introduction">2 Introduction</a>
<li><a name="toc_Installation" href="#Installation">3 Installation</a>
<ul>
<li><a href="#Installation">3.1 Install Dependencies</a>
<li><a href="#Installation">3.2 Getting Serveez-MG</a>
<li><a href="#Installation">3.3 Building and Installation</a>
<li><a href="#Installation">3.4 Testing</a>
</li></ul>
<li><a name="toc_Running-and-Managing" href="#Running-and-Managing">4 Running and Managing</a>
<ul>
<li><a href="#Running-and-Managing">4.1 Configuration is Code</a>
<li><a href="#Running-and-Managing">4.2 Trying Serveez</a>
</li></ul>
<li><a name="toc_An-example-Guile-server" href="#An-example-Guile-server">5 An example Guile server</a>
<ul>
<li><a href="#The-HELLO-protocol">5.1 The &ldquo;hello&rdquo; protocol</a>
<li><a href="#The-hello-world-server">5.2 The &ldquo;hello world&rdquo; server</a>
<ul>
<li><a href="#The-callback-functions">5.2.1 The callback functions</a>
</li></ul>
</li></ul>
<li><a name="toc_Deploying" href="#Deploying">6 Deploying</a>
<ul>
<li><a href="#Deploying">6.1 Command line options</a>
<li><a href="#Serveez-Configuration-Concepts">6.2 Serveez Configuration Concepts</a>
<ul>
<li><a href="#Define-ports">6.2.1 Define ports</a>
<ul>
<li><a href="#Define-ports">6.2.1.1 Port configuration items</a>
<li><a href="#Define-ports">6.2.1.2 TCP port definition</a>
<li><a href="#Define-ports">6.2.1.3 Pipe port definition</a>
<li><a href="#Define-ports">6.2.1.4 UDP port definition</a>
</li></ul>
<li><a href="#Define-servers">6.2.2 Define servers</a>
<li><a href="#Bind-servers-to-ports">6.2.3 Bind servers to ports</a>
</li></ul>
<li><a href="#Configuring-the-HTTP-Server">6.3 Configuring the HTTP Server</a>
<ul>
<li><a href="#Configuring-the-HTTP-Server">6.3.1 Configuration</a>
</li></ul>
<li><a href="#Setup-the-Control-Protocol-Server">6.4 Setup the Control Protocol Server</a>
<ul>
<li><a href="#Setup-the-Control-Protocol-Server">6.4.1 Configuration of the Control Protocol Server</a>
<li><a href="#Setup-the-Control-Protocol-Server">6.4.2 Using the Control Protocol</a>
</li></ul>
<li><a href="#Setup-the-Control-Protocol-Server">6.5 Additional configuration possibilities</a>
<ul>
<li><a href="#Setup-the-Control-Protocol-Server">6.5.1 Passthrough Server</a>
<ul>
<li><a href="#Setup-the-Control-Protocol-Server">6.5.1.1 General description</a>
<li><a href="#Setup-the-Control-Protocol-Server">6.5.1.2 Configuration</a>
</li></ul>
</li></ul>
</li></ul>
<li><a name="toc_Concept" href="#Concept">7 Concept</a>
<ul>
<li><a href="#Concept">7.1 Overall concept</a>
<li><a href="#Concept">7.2 I/O Strategy</a>
<ul>
<li><a href="#Concept">7.2.1 Limits on open filehandles</a>
</li></ul>
</li></ul>
<li><a name="toc_Server" href="#Server">8 Server</a>
<ul>
<li><a href="#Introduction-to-servers">8.1 Introduction to servers</a>
<li><a href="#Writing-servers">8.2 Writing servers in Guile</a>
<ul>
<li><a href="#Guile-servers">8.2.1 Guile server functions reference manual</a>
<ul>
<li><a href="#Guile-servers">8.2.1.1 Special Data Types</a>
<li><a href="#Guile-servers">8.2.1.2 Passing Binary Data</a>
<li><a href="#Guile-servers">8.2.1.3 Server Definition</a>
<li><a href="#Guile-servers">8.2.1.4 Callback Prototypes</a>
<li><a href="#Guile-servers">8.2.1.5 Predefined Procedures</a>
</li></ul>
</li></ul>
<li><a href="#Configuring-servers">8.3 Some words about server configuration</a>
</li></ul>
<li><a name="toc_Coserver" href="#Coserver">9 Coserver</a>
<ul>
<li><a href="#What-are-coservers">9.1 What are coservers</a>
<li><a href="#Existing-coservers">9.2 Existing coservers</a>
<ul>
<li><a href="#Existing-coservers">9.2.1 Identification (Ident) coserver</a>
<li><a href="#Existing-coservers">9.2.2 Domain Name Server (DNS) coserver</a>
<li><a href="#Existing-coservers">9.2.3 Reverse Domain Name Server (reverse DNS) coserver</a>
</li></ul>
</li></ul>
<li><a name="toc_Bibliography" href="#Bibliography">10 Bibliography</a>
<li><a name="toc_License" href="#License">11 License</a>
</li></ul>
</div>



<div class="node">
<a name="Top"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Preface">Preface</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#dir">(dir)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="unnumbered">Serveez-MG</h2>

<p>This manual is for Serveez-MG, version 0.2

<ul class="menu">
<li><a accesskey="1" href="#Preface">Preface</a>
<li><a accesskey="2" href="#Introduction">Introduction</a>
<li><a accesskey="3" href="#Installation">Installation</a>
<li><a accesskey="4" href="#Running-and-Managing">Running and Managing</a>
<li><a accesskey="5" href="#An-example-Guile-server">An example Guile server</a>
<li><a accesskey="6" href="#Deploying">Deploying</a>
<li><a accesskey="7" href="#Concept">Concept</a>
<li><a accesskey="8" href="#Server">Server</a>
<li><a accesskey="9" href="#Coserver">Coserver</a>
<li><a href="#Bibliography">Bibliography</a>
<li><a href="#License">License</a>

</li></ul>
<p>--- The Detailed Node Listing ---

<p>An example Guile server

</p>
<ul class="menu">
<li><a href="#The-HELLO-protocol">The HELLO protocol</a>
<li><a href="#The-hello-world-server">The hello world server</a>

</li></ul>
<p>The ``hello world'' server

</p>
<ul class="menu">
<li><a href="#The-callback-functions">The callback functions</a>

</li></ul>
<p>Command line options

</p>
<ul class="menu">
<li><a href="#Serveez-Configuration-Concepts">Serveez Configuration Concepts</a>
<li><a href="#Configuring-the-HTTP-Server">Configuring the HTTP Server</a>
<li><a href="#Setup-the-Control-Protocol-Server">Setup the Control Protocol Server</a>

</li></ul>
<p>Serveez Configuration Concepts

</p>
<ul class="menu">
<li><a href="#Define-ports">Define ports</a>:                 Port configuration definition
<li><a href="#Define-servers">Define servers</a>:               Server definition
<li><a href="#Bind-servers-to-ports">Bind servers to ports</a>:        How to bind servers to port configurations

</li></ul>
<p>Server

</p>
<ul class="menu">
<li><a href="#Introduction-to-servers">Introduction to servers</a>:      Protocol servers in Serveez
<li><a href="#Writing-servers">Writing servers</a>:              How to write Internet protocol servers
<li><a href="#Configuring-servers">Configuring servers</a>:          How do I configure an existing server ?

</li></ul>
<p>Writing servers in Guile

</p>
<ul class="menu">
<li><a href="#Guile-servers">Guile servers</a>:                Servers using Serveez's guile interface

</li></ul>
<p>Coserver

</p>
<ul class="menu">
<li><a href="#What-are-coservers">What are coservers</a>:           The use of coservers in Serveez
<li><a href="#Existing-coservers">Existing coservers</a>:           What kind of coservers already exist ?

   </ul>

<div class="node">
<a name="Preface"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Introduction">Introduction</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">1 Preface</h2>

<p>There was once a great server framework named GNU Serveez.  It was
basically a tutorial on how to implement an IP-based server as well as
a library and a framework to help you get things done.  It was
amazing: it supported dozens of platforms and many different ways of
serving content over the 'nets.

   <p>The code for it is still around, of course, on the GNU website, but,
the project appears to be dead, or mostly dead anyway.

   <p>Anyone that decided to pick up and update GNU Serveez would have a
Promethean task: with all those many operating systems laboriously
supported and with all those special cases for various libraries, it
would be a trial just to keep it from bitrotting.  It might actually
be impossible to keep it up to date without a huge community behind
it.  But it never really got that huge community it deserved.

   <p>When I (Mike Gran) wanted to make a Guile webservice, I decided to dust
GNU Serveez off and make it work for me, on my one specific platform. 
Serveez has built-in support for the Guile dialect of Scheme, which
makes it rather unique.  It is also unmaintained GNU code, which makes
me sad.

   <p>For now I call it &ldquo;Serveez-MG&rdquo; because the code is mostly GNU
Serveez, but, this is really a fork of the true GNU Serveez.  Don't
confuse the two.  This port is targeted to only work on my machines,
and it only implements a handful of the servers that GNU Serveez does. 
As a one person project, I needed to strip it down to something I
could understand.

<div class="node">
<a name="Introduction"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Installation">Installation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Preface">Preface</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">2 Introduction</h2>

<p>One function of Serveez-MG is as a web server.  It listens for HTTP
requests and then acts on them.  That part of it is boring.  In fact,
right now, is isn't a very modern webserver, since it requires
scripts to be in the <code>cgi-bin</code> directory.  This may soon change.

   <p>The other function of Serveez-MG is to provide a platform for
programming webservices in Guile.  It helps you write a webservice by
implementing a callback and event based server that will call your Guile
routines.  You won't have to worry about writing your own main poll or
select loop.

<div class="node">
<a name="Installation"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Running-and-Managing">Running and Managing</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Introduction">Introduction</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">3 Installation</h2>

<p>You can skip this section if you are familiar with the GNU'ish way of
configuring, compiling and installing a GNU package.

<h3 class="section">3.1 Install Dependencies</h3>

<p>This program depends on other programs that depend on other programs. 
Yadda yadda yadda.  It is &ldquo;turtles all the way down.&rdquo;

   <p>The most important dependencies are

     <ul>
<li>GNU Make for the building
<li>Guile 2.0 for the Scheme interpreter
<li>libcrypt for some trivial use of encryption
<li>libdl for some dynamic loading action
</ul>

   <p>Of the four, only Guile 2.0 is uncommon and is not part of the Linux
Standards Base.  It, in turn, depends on <samp><span class="file">libunistring</span></samp>, which is
also uncommon.

<h3 class="section">3.2 Getting Serveez-MG</h3>

<p>Serveez-MG can be found on
<a href="http://github.com/spk121/serveez-mg">http://github.com/spk121/serveez-mg</a>.  It might just be in a Git
repo, or there might be a download in the Download's directory.

<h3 class="section">3.3 Building and Installation</h3>

<p>If you're building this from the source code, then you will find a
file named 'INSTALL' in the source code package.  It has helpful
information on getting Serveez-MG to compile.  But, compiling from
source is a trial for the unfamiliar.  Maybe someday some GNU or Linux
distribution will package this, but, probably not.

<h3 class="section">3.4 Testing</h3>

<p>Once the code is all built, you should run its built-in test to see if
it is working by calling <code>make check</code>.  This check is not
comprehensive, but, does indicate that *something* is at least sort of
working.

<div class="node">
<a name="Running-and-Managing"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#An-example-Guile-server">An example Guile server</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Installation">Installation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">4 Running and Managing</h2>

<p>Before you can run Serveez-MG, you need to configure it for your
situation.  Serveez-MG is configured by writing a configuration file,
named <samp><span class="file">serveez.cfg</span></samp> in Scheme that gets read by Serveez-MG on
startup.

   <p>In this chapter, I'm going to explain the format for the configuration
file and all its options.  It is all based on the Scheme language, so
if you don't know Scheme, you might want to learn.  All the kids are
using it these days, if your definition of  &ldquo;kids&rdquo; is academics,
GNU enthusiasts, and fans of parentheses.

<h3 class="section">4.1 Configuration is Code</h3>

<p>This configuration file, <samp><span class="file">serveez.cfg</span></samp>, is actually a program in
the Scheme language.  Serveez-MG kicks off its Scheme interpreter when
it starts up.  It then adds several Serveez-specific procedures to the
Scheme interpreter: there are functions to define ports and servers,
and other networking functions that aren't normally available when
Guile starts up.  After this, it tries to run <samp><span class="file">serveez.cfg</span></samp>.

   <p>Since the configuration is code, you could put anything you liked in
there.  You could make you configuration file delete all the files on
your hard drive if you wished, though this is not recommended.  So
note that there is great versatility and great security risk to this.

<h3 class="section">4.2 Trying Serveez</h3>

<p>Just to keep you from getting bored, let's run Serveez now before we
dive into the complexities of the configuration file.

   <p>First, well add a minimal <samp><span class="file">serveez.cfg</span></samp> configuration file.

<pre class="example">     (serveez-verbosity 2)
     
     (define-port! 'http-port '(
                                ("proto"  . "tcp")
                                ("port"   . 10080)
                                ("ipaddr" . "*")))
     
     (define-server! 'http-server '(
                   ;; standard properties
                   ("admin"        . "nobody@gmail.com")
                   ("host"         . "yourdomain.net")
                   ("logfile"      . "http-access.log")
                   ("logformat"    . "%h %i %u [%t] \"%R\" %c %l")
                   ("docs"         . ".")
                   ("type-file"    . "/etc/mime.types")
                 ))
     
     (bind-server! 'http-port 'http-server)
</pre>
   <p>You'll also need to put an html file in this directory.  If you don't
have one, you can use this one: <samp><span class="file">hello.html</span></samp>

<pre class="example">     &lt;?xml version="1.0" encoding="US-ASCII"?&gt;
     &lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;
     &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
      &lt;head&gt;
       &lt;title&gt;Blammo!&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
       &lt;h1&gt;Blammo is the word&lt;/h1&gt;
      &lt;/body&gt;
     &lt;/html&gt;
</pre>
   <p>You can kick off the server by typing <code>serveez</code> on the command
line.  In this state, it will run in the foreground.

   <p>You then should be able to point your web browser to
<code>http://localhost:10080/hello.html</code>.

   <p>Once you are done messing about, you can kill the webserver with
&lt;CTRL-C&gt;.  It should have generated a <samp><span class="file">http-access.log</span></samp>
file, which you can now peruse.

<div class="node">
<a name="An-example-Guile-server"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Deploying">Deploying</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Running-and-Managing">Running and Managing</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">5 An example Guile server</h2>

<p>But, like I said, the <code>http</code> server is not that special.  Now I'll
give a description of the &ldquo;hello world&rdquo; of Guile webservices.  If you
have actually read this document from the beginning, you won't
understand the specifics of the commands; but, I find that it is easier
to scan this example, and then look at the specifics, and then re-read
the example, then it is to wade through reference material with no frame
of reference.

   <p>Now we'll describe an example server written in Guile.  The &ldquo;hello
world&rdquo; server.

<ul class="menu">
<li><a accesskey="1" href="#The-HELLO-protocol">The HELLO protocol</a>
<li><a accesskey="2" href="#The-hello-world-server">The hello world server</a>
</ul>

<div class="node">
<a name="The-HELLO-protocol"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-hello-world-server">The hello world server</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#An-example-Guile-server">An example Guile server</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#An-example-Guile-server">An example Guile server</a>

</div>

<h3 class="section">5.1 The &ldquo;hello&rdquo; protocol</h3>

<p>The first step in making our server is to define a protocol.  The
&ldquo;hello world&rdquo; server's protocol will be very simple.

   <p>First, when a client connects to the server, it needs to identify itself
by sending the ASCII string &ldquo;HELLO&rdquo;.

   <p>The server will respond by sending the string &ldquo;HELLO, WORLD!&rdquo;

   <p>Then, if the client sends the ASCII string &ldquo;WHAT TIME IS IT?&rdquo;, the server
will respond with an ASCII string representation of the time.

   <p>If the client sends any other data than that string, the server will
respond with the ASCII string &ldquo;ERROR&rdquo;.

<div class="node">
<a name="The-hello-world-server"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-HELLO-protocol">The HELLO protocol</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#An-example-Guile-server">An example Guile server</a>

</div>

<h3 class="section">5.2 The &ldquo;hello world&rdquo; server</h3>

<p>The &ldquo;hello world&rdquo; server is an Internet server completely written in
Guile with the help of the API provided by the underlying Serveez
application.  The reader will not see any occurrence of the networking
API of Guile.

   <p>This server is going to be a TCP server assigned to port 3003.

   <p>For the purposes of this example, imagine that all the following code
is in a file named <code>serveez.cfg</code>.

<ul class="menu">
<li><a accesskey="1" href="#The-callback-functions">The callback functions</a>
</ul>

<div class="node">
<a name="The-callback-functions"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-hello-world-server">The hello world server</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-hello-world-server">The hello world server</a>

</div>

<h4 class="subsection">5.2.1 The callback functions</h4>

<p>The first callback that needs to be defined in the <code>detect-proto</code>
callback.  It will scan for the client's initial string &ldquo;HELLO&rdquo;, which
is how the client identifies that it is trying to communicate to the
hello world server.

   <p>For TCP and PIPE servers this step is mandatory since there can be
multiple servers of different protocols listening to the same socket.

   <p>First, we need a couple of libraries
<pre class="lisp">     (use-modules (rnrs bytevectors)
     	     (serveez-mg lib))
</pre>
   <p>The <code>detect-proto</code> callback goes something like this:

<pre class="lisp">     ;; The protocol detection function: this function is called the
     ;; first time a client connects.  The client is expected to
     ;; identify itself by sending the string "HELLO".
     (define (hello-detect-proto server socket)
       (let ((input-bytes (svz:sock:receive-buffer socket)))
     
         (if (bytevector-contains (svz:sock:receive-buffer socket)
     			     (string-&gt;utf8 "HELLO"))
     	;; If true, allow connection
             1
     	;; Otherwise, ignore
     	0)))
</pre>
   <p>When the client connects to the server, whatever
it has sent is stored in the <em>receive buffer</em>.  The procedure
<code>svz:sock:receive-buffer</code> returns a bytevector containing
everything received so far from the client.  Note that this procedure
does not then erase the data from the receive buffer.

   <p>Next, we need the 'connect-socket' callback.  This is called once per
connection that has a valid protocol.  This procedure is used to set up
the socket and then connect a request handler to it.

<pre class="lisp">     ;; The connect socket function: after a client has been detected by
     ;; detect-proto, this function handles each request
     (define (hello-connect-socket server socket)
       ;; Each packet is going to be delimited by CR/LF
       (svz:sock:boundary socket "\r\n")
       ;; Connect to the request handler
       (svz:sock:handle-request socket hello-handle-request)
       ;; Zero indicates success
       0)
</pre>
   <p>This procedure tells the socket to chop input data into packets
delimited by the carriage-return / linefeed pair.  Each set of
input that ends with CR/LF will be considered its own packet and will be
processed as a single request.

   <p>Then, it connects the procedure <code>hello-handle-request</code> to the
socket as its request handler.  It will get called once per packet.  So
now, of course, we need a request handler.

<pre class="lisp">     ;; The request handler.
     ;; If it receives "HELLO", return "HELLO, WORLD!".
     ;; If it receives "WHAT TIME IT IS?", return the time.
     ;; Otherwise, return ERROR.
     (define (hello-handle-request socket request len)
       (let ((command (strip-boundary (utf8-&gt;string request))))
         (cond
          ((string=? command "HELLO")
           (svz:sock:print socket "HELLO, WORLD!\r\n"))
          ((string=? command "WHAT TIME IS IT?")
           (svz:sock:print socket (strftime "%c" (localtime (current-time))))
           (svz:sock:print socket "\r\n"))
          (else
           (svz:sock:print socket "ERROR\r\n")))
         ;; Return zero to indicate success
         0))
     
     (define (strip-boundary str)
       (string-trim-right str (string-&gt;char-set "\r\n")))
</pre>
   <p>This request handler does all the heavy lifting.  If it receives
a &ldquo;HELLO&rdquo; or &ldquo;WHAT TIME IS IT?&rdquo; command, it will respond
appropriately.

   <p>Now that the callbacks are out of the way, we need to create the port
and server.  The port is a TCP port on port number 3003.

<pre class="lisp">     ;; Port configuration
     (define-port! 'hello-port '((proto . tcp)
     			    (port . 3003))
</pre>
   <p>The hello server is defined and the callbacks are connect to it like so:

<pre class="lisp">     (define-servertype!
       '((prefix  . "hello")
         (description . "guile hello world server")
         (detect-proto . hello-detect-proto)
         (connect-socket . hello-connect-socket)
         (configuration . ())
         ))
</pre>
   <p>The prefix is used to create a name for the new server type: the
<code>hello-server</code>.  Then its two main callbacks,
<code>hello-detect-proto</code> and <code>hello-connect-socket</code>, are connected
to this server type.  The <code>hello-handle-request</code> callback is not
mentioned here because it needs to be connected to a socket once it has
been opened.  That is why it is connected to a socket in the
<code>hello-connect-socket</code> callback routine.

   <p>Lastly, an instance of the server is created and bound to the port.

<pre class="lisp">     ;; Server instantiation
     (define-server! 'hello-server '())
     
     (bind-server! 'hello-port 'hello-server)
</pre>
   <p>With all this in place, running <code>serveez</code> like so

<pre class="example">     serveez
</pre>
   <p>should start up the server.  If your <code>serveez.cfg</code> file isn't in
this directory, you'll have to call <code>serveez -f
&lt;path&gt;/serveez.cfg</code>.

   <p>We used CR/LF as packet boundaries, which means that we can test this
using a telnet program.  If you telnet to port 3003, you should be able
to type in the commands <code>HELLO</code> and <code>WHAT TIME IS IT?</code> and see
the response from the server.

<div class="node">
<a name="Deploying"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Concept">Concept</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#An-example-Guile-server">An example Guile server</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">6 Deploying</h2>

<p>When Serveez-MG is started it reads its configuration from a file
called <samp><span class="file">serveez.cfg</span></samp> in the current directory and runs the server
loop afterwards. Press &lt;^C&gt; to abort the execution of this
program.  Serveez-MG is not interactive and does not automatically
detach from the terminal.

<h3 class="section">6.1 Command line options</h3>

     <dl>
<dt><code>-h, --help</code><dd>Display this help and exit. 
<br><dt><code>-V, --version</code><dd>Display version information and exit. 
<br><dt><code>-i, --iflist</code><dd>List local network interfaces and exit. 
<br><dt><code>-f, --cfg-file=FILENAME</code><dd>File to use as configuration file (serveez.cfg). 
<br><dt><code>-v, --verbose=LEVEL</code><dd>Set level of logging verbosity. 
<br><dt><code>-l, --log-file=FILENAME</code><dd>Use <code>FILENAME</code> for logging (default is stderr). 
<br><dt><code>-P, --password=STRING</code><dd>Set the password for control connections. 
<br><dt><code>-m, --max-sockets=COUNT</code><dd>Set the maximum number of socket descriptors. 
<br><dt><code>-d, --daemon</code><dd>Start as daemon in background. 
<br><dt><code>-c, --stdin</code><dd>Use standard input as configuration file. 
</dl>

<ul class="menu">
<li><a accesskey="1" href="#Serveez-Configuration-Concepts">Serveez Configuration Concepts</a>
<li><a accesskey="2" href="#Configuring-the-HTTP-Server">Configuring the HTTP Server</a>
<li><a accesskey="3" href="#Setup-the-Control-Protocol-Server">Setup the Control Protocol Server</a>
</ul>

<div class="node">
<a name="Serveez-Configuration-Concepts"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Configuring-the-HTTP-Server">Configuring the HTTP Server</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Deploying">Deploying</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Deploying">Deploying</a>

</div>

<h3 class="section">6.2 Serveez Configuration Concepts</h3>

<p>As noted above Serveez is configured via a configuration file which is
by default <samp><span class="file">serveez.cfg</span></samp> and can be set by passing the &lsquo;<samp><span class="samp">-f</span></samp>&rsquo;
command line argument.  When you pipe a file into Serveez or pass the
&lsquo;<samp><span class="samp">-c</span></samp>&rsquo; argument on the command line the input stream will be used
as configuration file no matter whether you passed a &lsquo;<samp><span class="samp">-f</span></samp>&rsquo; command
line switch or not.

   <p>The idea of the configuration file is this: Serveez starts, the
configuration file (which is Scheme code) is run, and then it enters its
main loop and waits for connections.  If your configuration file
contained Serveez commands to set up the http server to create a Guile
webservice, then they will be available.  If your configuration file
does neither of those things, Serveez will have no servers available.

   <p>There are three things you have to do in the configuration file to make
a server available:

     <ul>
<li>define your ports
<li>define your servers
<li>and, bind your servers to the ports
</ul>

   <p>In the next three sections, this process will be described in a
general sense.  Afterwards, we'll describe specifically how to set up
the webserver and the control server.

<ul class="menu">
<li><a accesskey="1" href="#Define-ports">Define ports</a>:                 Port configuration definition
<li><a accesskey="2" href="#Define-servers">Define servers</a>:               Server definition
<li><a accesskey="3" href="#Bind-servers-to-ports">Bind servers to ports</a>:        How to bind servers to port configurations
</ul>

<div class="node">
<a name="Define-ports"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Define-servers">Define servers</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Serveez-Configuration-Concepts">Serveez Configuration Concepts</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Serveez-Configuration-Concepts">Serveez Configuration Concepts</a>

</div>

<h4 class="subsection">6.2.1 Define ports</h4>

<p>A <code>port</code> (in Serveez) is a transport endpoint. You might know them
from other TCP or UDP server applications. For example: web servers
(HTTP) usually listen on TCP port 80. However, there is more than TCP
ports: we have UDP, ICMP and named pipes each with different options to
set. Every port has a unique name you assign to it. The name of the port is
later used to bind servers to it.

   <p>The following examples show how you setup different types of port
configurations. You start to define such a port using the Guile function
<code>(define-port!)</code>. The first argument to this functions specifies the
name of the port configuration. The remaining argument describes the
port in detail. A definition of the http-port could be like the following.

<pre class="example">     (define-port! 'http-port '(("proto"  . "tcp")
                                ("port"   . 80)
                                ("ipaddr" . "*")))
</pre>
   <p>In this example, <code>define-port!</code> is a command that you are asking
Serveez to do; <code>http-port</code> is the name you're assigning to the
port you're making. Following that is a list of configuration items
that are being set: the port protocol is set to TCP; the port number
is set to 80, which is customary for the HTTP port, and the port will
accept connections from the whole range of possible IP addresses.

<h5 class="subsubsection">6.2.1.1 Port configuration items</h5>

<p>This table describes each configuration item for a port in Serveez.  Note
that not each item applies to every kind of port configuration.

     <dl>
<dt><code>proto (string)</code><dd>This is the main configuration item for a port configuration setting up the
type of port.  Valid values are &lsquo;<samp><span class="samp">tcp</span></samp>&rsquo;, &lsquo;<samp><span class="samp">udp</span></samp>&rsquo;, &lsquo;<samp><span class="samp">icmp</span></samp>&rsquo;,
&lsquo;<samp><span class="samp">raw</span></samp>&rsquo; and &lsquo;<samp><span class="samp">pipe</span></samp>&rsquo;.  This configuration item decides which of the
remaining configuration items apply and which do not.

     <br><dt><code>port (integer in the range 0..65535)</code><dd>The <code>port</code> item determines the network port number on which TCP
and UDP servers will listen.  Thus it does not make sense for ICMP and
named pipes.  If you pass &lsquo;<samp><span class="samp">0</span></samp>&rsquo; Serveez will determine a free port
in the range between 1 and 65535.  Remember that port numbers below
1024 are privileged ports and only privileged processes, such as those
run as root, can bind to them.

     <br><dt><code>recv (string or associative list)</code><dd>This item describes the receiving (listening) end of a named pipe
connection, i.e. the filename of a fifo node to which a client can
connect by opening it for writing.  Both the <code>recv</code> and <code>send</code>
item apply to named pipes only.  The value can either be an associative
list or a simple filename. Using a simple filename leaves additional
options to use default values. They deal mainly with file permissions
and are described below.

     <br><dt><code>send (string or associative list)</code><dd>This item is the sending end of a named pipe connection. It is used to
send data when the receiving (listening) end has detected a connection. 
The following table enumerates the additional options you can
setup if you pass an associative list and not a simple filename.

          <dl>
<dt><code>name (string)</code><dd>The filename of the named pipe.

          <br><dt><code>permission (octal integer)</code><dd>This specifies the file permissions a named pipe should be created with. 
The given number is interpreted in a Unix'ish style (e.g. &lsquo;<samp><span class="samp">#o0666</span></samp>&rsquo;
is a permission field for reading and writing for the creating user, all
users in the same group and all other users).

          <br><dt><code>user (string)</code><dd>The file owner (username) of the named pipe in textual form.

          <br><dt><code>group (string)</code><dd>The file owner group (groupname) of the named pipe in textual form.  If
this item is left it defaults to the file owner's primary group.

          <br><dt><code>uid (integer)</code><dd>The file owner of the named pipe as a user id.  You are meant to specify
either the <code>uid</code> item or the <code>user</code> item.  Serveez will
complain about conflicting values.

          <br><dt><code>gid (integer)</code><dd>The file owner group of the named pipe as a group id.  This item
defaults to the file owner's primary group id.  You are meant to specify
either the <code>gid</code> item or the <code>group</code> item.  Serveez will croak
about conflicting values. 
</dl>

     <br><dt><code>ipaddr (string)</code><dd>This configuration item specifies the IP address (either in dotted decimal
form e.g. &lsquo;<samp><span class="samp">192.168.2.1</span></samp>&rsquo; or as a device description which can be
obtained via &lsquo;<samp><span class="samp">serveez -i</span></samp>&rsquo;) to which a server is bound to.  The
&lsquo;<samp><span class="samp">*</span></samp>&rsquo; keyword for all known IP addresses and the &lsquo;<samp><span class="samp">any</span></samp>&rsquo; keyword for
any IP address are also valid values.  The default value is &lsquo;<samp><span class="samp">*</span></samp>&rsquo;.  The
configuration item applies to network ports (TCP, UDP and ICMP) only.

     <br><dt><code>device (string)</code><dd>The <code>device</code> configuration item also refers to the IP address a server
can be bound to.  It overrides the <code>ipaddr</code> item.  Valid values are
network device descriptions (probably no aliases and no loopback devices). 
It applies to network ports (TCP, UDP and ICMP) only.

     <br><dt><code>backlog (integer)</code><dd>The <code>backlog</code> parameter defines the maximum length the queue of
pending connections may grow to.  If a connection request arrives with the
queue full the client may receive an error.  This parameter applies to
TCP ports only.

     <br><dt><code>type (integer in the range 0..255)</code><dd>This item applies to ICMP ports only.  It defines the message type
identifier used to send ICMP packets (e.g. &lsquo;<samp><span class="samp">8</span></samp>&rsquo; is an echo message
i.e. PING).

     <br><dt><code>send-buffer-size (integer)</code><dd>The <code>send-buffer-size</code> configuration item defines the maximum number
of bytes the send queue of a client is allowed to grow to.  The item
influences the "send buffer overrun error condition".  For packet oriented
protocols (UDP and ICMP) you need to specify at least the maximum number
of bytes a single packets can have.  For UDP and ICMP this is 64 KByte. 
The value specified here is an initial value. It is used unless the
server bound to this port changes it.

     <br><dt><code>recv-buffer-size (integer)</code><dd>The <code>recv-buffer-size</code> configuration item defines the maximum
number of bytes the receive queue of a client is allowed to grow to. 
The item influences the "receive buffer underrun error condition".  The
value specified here is an initial value. It is used unless the server
bound to this port changes it.

     <br><dt><code>connect-frequency (integer)</code><dd>This item determines the maximum number of connections per second the port
will accept.  It is a kind of "hammer protection".  The item is evaluated
for each remote client machine separately.  It applies to TCP ports.

     <br><dt><code>allow (list of strings)</code><dd>Both the <code>allow</code> and <code>deny</code> lists are lists of IP addresses in
dotted decimal form (e.g. &lsquo;<samp><span class="samp">192.168.2.1</span></samp>&rsquo;). The <code>allow</code> list defines
the remote machines which are allowed to connect to the port.  It applies
to TCP ports.

     <br><dt><code>deny (list of strings)</code><dd>The <code>deny</code> list defines the remote machines which are not allowed to
connect to the port.  Each connection from one of these IP addresses will
be refused and shut down immediately.  It applies to TCP ports. 
</dl>

<h5 class="subsubsection">6.2.1.2 TCP port definition</h5>

<p>As another example, here is a definition of a TCP port configuration
with the name "foo-tcp-port". The enhanced settings are all optional
including the <var>ipaddr</var> property which defaults to &lsquo;<samp><span class="samp">*</span></samp>&rsquo;. The
<var>ipaddr</var> item can contain any form of a dotted decimal internet
address, a &lsquo;<samp><span class="samp">*</span></samp>&rsquo;, &lsquo;<samp><span class="samp">any</span></samp>&rsquo; or an interface description which you
can obtain by running &lsquo;<samp><span class="samp">serveez -i</span></samp>&rsquo;.

<pre class="example">     (define-port! 'foo-tcp-port '(
         ;; usual settings
         (proto  . tcp)              ;; protocol is tcp
         (port   . 42421)            ;; network port 42421
         (ipaddr . *)                ;; bind to all known interfaces
         (device . eth0)             ;; bind to network card
     
         ;; enhanced settings
         (backlog           . 5)     ;; enqueue max. 5 connections
         (connect-frequency . 1)     ;; allow 1 connect per second
         (send-buffer-size  . 1024)  ;; initial send buffer size in bytes
         (recv-buffer-size  . 1024)  ;; initial receive buffer size in bytes
     
         ;; allow connections from these ip addresses
         (allow             . (127.0.0.1 127.0.0.2))
     
         ;; refuse connections from this ip address
         (deny              . (192.168.2.7))
       ))
</pre>
   <h5 class="subsubsection">6.2.1.3 Pipe port definition</h5>

<p>Definition of a pipe port configuration with the name "foo-pipe-port". 
When bound to a server it creates the receiving end and listens on that. 
If some client accesses this named pipe the server opens the sending end
which the client has to open for reading previously.

   <p>The only mandatory item is the file name of each pipe.  If you want to
specify a user creating the named pipe (file ownership) use either the
<var>user</var> or the <var>uid</var> setting.  Same goes for the items
<var>group</var> and <var>gid</var>.

<pre class="example">     (define-port! 'foo-pipe-port `(
         (proto . pipe)                   ;; protocol is named pipe
     
         ;; specify the receiving endpoint
         (recv . ((name . ".foo-recv")    ;; name of the pipe
                  (permissions . #o0666)  ;; create it with these permissions
                  (user . "calvin")       ;; as user "calvin"
                  (uid . 50)              ;; with the user id 50
                  (group . "heros")       ;; which is in the group "heros"
                  (gid . 100)))           ;; with the group id 100
     
         ;; specify the sending endpoint
         (send . ((name . ".foo-send")
                  (permissions . #o0666)
                  (user . "hobbes")
                  (uid . 51)
                  (group . "stuffed")
                  (gid . 101)))
        ))
</pre>
   <h5 class="subsubsection">6.2.1.4 UDP port definition</h5>

<p>Simple definition of a UDP port configuration with the name "foo-udp-port".

<pre class="example">     (define-port! 'foo-udp-port `((proto . udp)
                                   (port  . 27952)))
</pre>
   <div class="node">
<a name="Define-servers"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Bind-servers-to-ports">Bind servers to ports</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Define-ports">Define ports</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Serveez-Configuration-Concepts">Serveez Configuration Concepts</a>

</div>

<h4 class="subsection">6.2.2 Define servers</h4>

<p>A <code>server</code> (in Serveez) is code that implements some
protocol. There is an HTTP server built into Serveez &ndash; and a control
server and a 'passthrough' server that we'll describe later &ndash; but you
can implement your own, too. Each server &ndash; either serveez's http
server, passthrough server, or control server or any servers you
implement yourself in Scheme &ndash; has a different set of options you can
change. You can have many instances of every server, each with a
different set of options. For example: You can create a webserver on TCP
port 42420 publishing the Serveez documentation and also have another
webserver on a different port publishing something else. Every server
has a unique name you assign to it. The name of the server is later used
to bind it to a port.

   <p>Each type of port will have its own specific list of configuration
parameters.  The HTTP server has a different set of configuration
parameters than another type of server.

   <p>The following example instantiates a server with the short name
"foo". This example demonstrates all the different data types that might
appear in server configurations. You start a definition of a server with
the guile function <code>(define-server!)</code>. The following argument
specifies the name of the server instance (in this case "foo-server")
which starts with the short name. The second argument describes the
server in detail. Each configuration item is setup with a <code>(key
. value)</code> pair where "key" is the name of the configuration item and
"value" is the value which depends on the type of the
item. See <a href="#Configuring-servers">Configuring servers</a>, for a detailed description of each
type of value.

<pre class="example">     (define-server! 'foo-server '(
         (bar . 100)                             ;; number
         (reply . "Booo")                        ;; character string
         (messages .                             ;; list of strings
           ("Welcome to the foo test server."
            "This one echos your lines."))
         (ports . (5 6 7 8 9))                   ;; list of numbers
         (port . foo-tcp-port)                   ;; a port configuration
         (assoc . (( "GNU" . "great" )           ;; associative list
                   ( "Tree" . "tall" )))
         (truth . #f)                            ;; boolean value
       ))
</pre>
   <div class="node">
<a name="Bind-servers-to-ports"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Define-servers">Define servers</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Serveez-Configuration-Concepts">Serveez Configuration Concepts</a>

</div>

<h4 class="subsection">6.2.3 Bind servers to ports</h4>

<p>Finally you can bind servers to ports. When you do so the server you
created listens on the port, accepts connections and serves clients. It
does so as soon as Serveez enters its main loop right after running the
configuration file. Serveez won't stop until you interrupt it (e.g. by
pressing &lt;^C&gt; in the terminal you started it in).

   <p>This example binds the server "foo-server" (s.a.) to the port "foo-tcp-port"
which was described above. Therefore you need to call the guile function
<code>(bind-server!)</code> which takes two arguments specifying the name of a port
configuration and a server instance. Both need to be defined before
you can write this statement.

<pre class="example">     (bind-server! 'foo-tcp-port 'foo-server)
</pre>
   <p>One of the main features of Serveez is that you can bind multiple
servers to the same port. This for example is useful to pass braindead
firewall configurations or proxy servers. It is also possible to bind
servers to ports they are actually not designed for. This might be used
for debugging servers or other funny things (again, think about the
firewall). This is the point we have to warn you: Some protocols cannot
share the same port (e.g. the tunnel server) and some protocols simply won't
work on 'wrong' ports. Additionally, you will not get error messages when
that happens. The server just will not work then.

<div class="node">
<a name="Configuring-the-HTTP-Server"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Setup-the-Control-Protocol-Server">Setup the Control Protocol Server</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Serveez-Configuration-Concepts">Serveez Configuration Concepts</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Deploying">Deploying</a>

</div>

<h3 class="section">6.3 Configuring the HTTP Server</h3>

<p>The integrated HTTP server was originally meant to be a simple but
fast document server. It can also execute CGI scripts. The GET, HEAD
and POST methods are fully functional. Additionally Serveez produces
directory listings when no standard document file
(e.g. <samp><span class="file">index.html</span></samp>) has been found at the requested document node
(directory).  Furthermore it implements a file cache for speeding up
repetitive HTTP request.

   <p>For now, this HTTP server uses old concepts of web content.  It assumes
that everything that is to be served is either static content like
webpages and images, or is a CGI (Common Gateway Interface) script that
is placed in the CGI directory.  This will change in the future so that
any URI can be used to serve dynamic content, instead of just scripts in
the CGI directory.

   <p>The basic setup of the HTTP server requires that the serveez.cfg file
contains something like the following:

<pre class="example">     (define-port! 'http-port '(
                                ("proto"  . "tcp")
                                ("port"   . 80)
                                ("ipaddr" . "*")))
     
     (define-server! 'http-server '(
                   ;; standard properties
                   ("admin"        . "nobody@gmail.com")
                   ("host"         . "yourdomain.net")
                   ("logfile"      . "http-access.log")
                   ("logformat"    . "%h %i %u [%t] \"%R\" %c %l")
                   ("indexfile"    . "index.html")
                   ("docs"         . "/var/www/html")
                   ("userdir"      . "public_html")
                   ("type-file"    . "/etc/mime.types")
                   ("default-type" . "text/plain")
                   ("nslookup"     . on)
                   ("ident"        . yes)
     
                   ;; cgi interface
                   ("cgi-url"         . "/cgi-bin")
                   ("cgi-dir"         . "/var/www/cgi-bin")
                   ("cgi-application" . (("pl"  . "perl")
                                         ("py"  . "python")))
                 ))
     
     (bind-server! 'http-port 'http-server
</pre>
   <p>Remember that port numbers below 1024 are privileged ports and only
privileged processes, such as those run as root, can bind to them.

<h4 class="subsection">6.3.1 Configuration</h4>

<p>The following options for the HTTP server can be set from the
configuration file.

     <dl>
<dt><code>indexfile (string, default: index.html)</code><dd>The <code>indexfile</code> parameter is the default file served by the HTTP
server when the user does not specify a file but a document node
(e.g. <a href="http://www.lkcc.org/">http://www.lkcc.org/</a>).

     <br><dt><code>docs (string, default: ../show)</code><dd>The <code>docs</code> parameter is the document root where the server finds its
web documents.

     <br><dt><code>userdir (string, default: public_html)</code><dd>Each &lsquo;<samp><span class="samp">~user</span></samp>&rsquo; request gets converted into the given users home
directory. The string will be appended to this directory. Its default
value is &lsquo;<samp><span class="samp">public_html</span></samp>&rsquo;.

     <br><dt><code>cgi-url (string, default: /cgi-bin)</code><dd>This parameter is the first part of the URL the HTTP server identifies a
CGI request. For instance if you specify here <samp><span class="file">/cgi-bin</span></samp> and the
user requests <a href="http://www.lkcc.org/cgi-bin/test.pl">http://www.lkcc.org/cgi-bin/test.pl</a> then the
HTTP server tries to execute the program <samp><span class="file">test.pl</span></samp> within the
<code>cgi-dir</code> (see below) and pipes its output to the user.

     <br><dt><code>cgi-dir (string, default: ./cgibin)</code><dd>The <code>cgi-dir</code> is the CGI document root (on the server).

     <br><dt><code>cgi-application (hash, default: empty)</code><dd>You can use this hash to associate certain file suffices with
applications on your computer (e.g. "pl" with "perl").

     <br><dt><code>cache-size (integer, default: 200 kb)</code><dd>This specifies the size of the document cache in bytes for each cache
entry.

     <br><dt><code>cache-entries (integer, default: 64)</code><dd>This parameter specifies the maximum number of HTTP file cache entries
(files). When you instantiate more than one HTTP server the biggest value
wins. The HTTP file cache is shared by all HTTP servers.<br>
<strong>Please note</strong>: If your harddrive/filesystem combination proves to
be faster than the HTTP file cache you should disable it by setting both
<code>cache-size</code> and <code>cache-entries</code> to zero.

     <br><dt><code>timeout (integer, default: 15)</code><dd>The <code>timeout</code> value is the amount of time in seconds after which
a keep-alive connection (this is a HTTP/1.1 feature) will be closed when
it has been idle.

     <br><dt><code>keepalive (integer, default: 10)</code><dd>On one keep-alive connection can be served the number of <code>keepalive</code>
documents at all. Then the connection will be closed. 
Both this and the <code>timeout</code> value are just to be on the safe side. 
They protect against idle and high traffic connections.

     <br><dt><code>default-type (string, default: text/plain)</code><dd>The <code>default-type</code> is the default content type the HTTP server
assumes if it can not identify a served file by the <code>types</code> hash
and the <code>type-file</code> (see below).

     <br><dt><code>type-file (string, default: /etc/mime.types)</code><dd>This should be a file like the <samp><span class="file">/etc/mime.types</span></samp> on Unix systems. 
It associates file suffices with MIME types.

     <br><dt><code>types (hash, default: empty)</code><dd>If you want to specify special content types do it here. This parameter
is a hash map associating file suffices with HTTP content types (MIME types).

     <br><dt><code>admin (string, default: root@localhost)</code><dd>Your address, where problems with the server should be e-mailed. 
This address appears on some server-generated pages, such as error
documents.

     <br><dt><code>host (string, default: localhost)</code><dd>This is the native host name of your web server. Sometimes the server has
to send back its own name to the client. It will use this value. 
Be aware that you cannot invent such a name.

     <br><dt><code>nslookup (boolean, default: false)</code><dd>If this is true the HTTP server invokes a reverse DNS lookup
for each client connection in order to replace the remote ip address with
the remote host name in the access logfile.

     <br><dt><code>ident (boolean, default: false)</code><dd>If this is true the HTTP server processes identd requests
for each client connection for logging purposes.

     <br><dt><code>logfile (string, default: http-access.log)</code><dd>The location of the access logfile. For each HTTP request a line gets
appended to this file.

     <br><dt><code>logformat (string, default: CLF)</code><dd>The format of the access logfile. There are special placeholders for
different kinds of logging information. The default log format is the
Common Log Format (CLF). It contains a separate line for each request. A
line is composed of several tokens separated by spaces.
     <pre class="example">          CLF = host ident authuser date request status bytes
</pre>
     <p>If a token does not have a value then it is represented by a hyphen (-). 
The meanings and values of these tokens are as follows:

          <dl>
<dt><code>%h (host)</code><dd>The fully-qualified domain name of the client, or its IP number if the name
is not available. 
<br><dt><code>%i (ident)</code><dd>This is the identity information reported by the client. Not active, so
we will see a hyphen (-). 
<br><dt><code>%u (authuser)</code><dd>If the request was for an password protected document, then this is the
userid used in the request. 
<br><dt><code>%t (date)</code><dd>The date and time of the request, in the following format:
          <pre class="example">               date   = [day/month/year:hour:minute:second zone]
               day    = 2*digit
               month  = 3*letter
               year   = 4*digit
               hour   = 2*digit
               minute = 2*digit
               second = 2*digit
               zone   = (`+' | `-') 4*digit
</pre>
          <br><dt><code>%R (request)</code><dd>The request line from the client, enclosed in double quotes ("). 
<br><dt><code>%r (referrer)</code><dd>Which document referred to this document. 
<br><dt><code>%a (agent)</code><dd>What kind of web browser did the remote client use. 
<br><dt><code>%c (status)</code><dd>The three digit status code returned to the client. 
<br><dt><code>%l (bytes)</code><dd>The number of bytes in the object returned to the client, not including
any headers. 
</dl>
     </dl>

<div class="node">
<a name="Setup-the-Control-Protocol-Server"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Configuring-the-HTTP-Server">Configuring the HTTP Server</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Deploying">Deploying</a>

</div>

<h3 class="section">6.4 Setup the Control Protocol Server</h3>

<p>Now that you've added the configuration for the HTTP server to the
<samp><span class="file">serveez.cfg</span></samp> configuration file, the next step is to set up the
Control Protocol Server, which allows you to do some administration on
the server process without having to stop and restart it.

   <p>To this end, Serveez implements something like a telnet protocol for
administrative purposes. You just need to start a telnet session like:
<pre class="example">     $ telnet www.yourdomain.org 42420
</pre>
   <p>After pressing &lt;RET&gt; you will be asked for a password which you
might setup passing Serveez the -P argument.

<h4 class="subsection">6.4.1 Configuration of the Control Protocol Server</h4>

<p>The control protocol server doesn't have many options to configure. 
But, in the <samp><span class="file">serveez.cfg</span></samp> file, you need to bind it to a TCP
port, like so:

<pre class="example">     (define-port! 'control-port `(
     			      (proto . tcp)
     			      (port . 42420)
     			      (ipaddr . *)
     			      ))
     
     (define-server! 'control-server)
     
     (bind-server! 'control-port 'control-server)
</pre>
   <p>This example has it bound to port 42420, so you would telnet to that
port.

   <p>The password that the Control Protocol Server will expect can be set
in a couple of ways.  It can be specified on the command line when
Serveez is invoked.  It can also be set in the <samp><span class="file">serveez.cfg</span></samp> file
by using the <code>serveez-passwd</code> procedure.

<h4 class="subsection">6.4.2 Using the Control Protocol</h4>

<p>Once you've connected to the Control Protocl Server via telnet, you'll
be given a prompt at which you can enter the following commands.

     <dl>
<dt>&lsquo;<samp><span class="samp">help</span></samp>&rsquo;<dd>This command will give you a very short help screen of all available
commands.

     <br><dt>&lsquo;<samp><span class="samp">quit</span></samp>&rsquo;<dd>This command closes the connection to Serveez.

     <br><dt>&lsquo;<samp><span class="samp">restart ident</span></samp>&rsquo;<dd>Restarts the internal ident coserver. This is useful if you just want
to start a new one if the old one died or is otherwise unusable.

     <br><dt>&lsquo;<samp><span class="samp">restart dns</span></samp>&rsquo;<dd>Restarts the internal dns lookup server.

     <br><dt>&lsquo;<samp><span class="samp">restart reverse dns</span></samp>&rsquo;<dd>Restarts the internal reverse dns lookup server.

     <br><dt>&lsquo;<samp><span class="samp">killall</span></samp>&rsquo;<dd>This might be useful if Serveez seems to be unstable but you do not
want to restart it. With &lsquo;<samp><span class="samp">killall</span></samp>&rsquo; you disconnect all client
network connections except the control protocol connections.

     <br><dt>&lsquo;<samp><span class="samp">kill id NUM</span></samp>&rsquo;<dd>Disconnects a specific connection identified by its ID. These IDs will
be stated when you type &lsquo;<samp><span class="samp">stat con</span></samp>&rsquo; (see below).

     <br><dt>&lsquo;<samp><span class="samp">stat</span></samp>&rsquo;<dd>General statistics about Serveez. This will show you some useful
information about the computer Serveez is running on and about the
state of Serveez in general.

     <br><dt>&lsquo;<samp><span class="samp">stat coserver</span></samp>&rsquo;<dd>Statistics about all running coserver instances.

     <br><dt>&lsquo;<samp><span class="samp">stat SERVER</span></samp>&rsquo;<dd>This command is for selecting certain server instances to be listed. 
SERVER is one of server names you specified in the configuration file.

     <br><dt>&lsquo;<samp><span class="samp">stat id NUM</span></samp>&rsquo;<dd>Show statistics about a specific connection. This will give you all
available information about every connection you specified. 
See <a href="#Writing-servers">Writing servers</a>, for more information about how to provide these
information.

     <br><dt>&lsquo;<samp><span class="samp">stat con</span></samp>&rsquo;<dd>Connection statistics. This will give a list of all socket structures
within Serveez. If you want more detailed information about specific
connections, coservers or servers you need to request these information
with &lsquo;<samp><span class="samp">stat id NUM</span></samp>&rsquo; or &lsquo;<samp><span class="samp">stat all</span></samp>&rsquo;.

     <br><dt>&lsquo;<samp><span class="samp">stat all</span></samp>&rsquo;<dd>Server and coserver instance statistics. This command lists all
the information about instantiated servers and coservers. 
See <a href="#Writing-servers">Writing servers</a>, for more information about how to provide these
information.

     <br><dt>&lsquo;<samp><span class="samp">stat cache</span></samp>&rsquo;<dd>HTTP cache statistics. This command produces an output something like the
following where &lsquo;<samp><span class="samp">File</span></samp>&rsquo; is the short name of the cache entry,
&lsquo;<samp><span class="samp">Size</span></samp>&rsquo; the cache size, &lsquo;<samp><span class="samp">Usage</span></samp>&rsquo; the amount of connections
currently using this entry, &lsquo;<samp><span class="samp">Hits</span></samp>&rsquo; the amount of cache hits,
&lsquo;<samp><span class="samp">Recent</span></samp>&rsquo; the cache strategy flag (newer entries have larger numbers)
and &lsquo;<samp><span class="samp">Ready</span></samp>&rsquo; is the current state of the cache entry.

     <pre class="example">          File                      Size  Usage  Hits Recent Ready
          zlib-1.1.3-20000531.zip  45393      0     0      1 Yes
          texinfo.tex             200531      0     0      2 Yes
          shayne.txt                2534      0     1      1 Yes
          
          Total : 248458 byte in 3 cache entries
</pre>
     <br><dt>&lsquo;<samp><span class="samp">kill cache</span></samp>&rsquo;<dd>Reinitialize the HTTP file cache. Flushes all files from the cache. 
</dl>

<h3 class="section">6.5 Additional configuration possibilities</h3>

<p>The three functions <code>(define-port!)</code>, <code>(define-server!)</code> and
<code>(bind-server!)</code> return <code>#t</code> on success and <code>#f</code> on
failure.  For your convenience we provide some more Guile functions. 
Some of these are based upon the above.  You will find the additional
functions in <code>(serveez-mg lib)</code> library that will be copied into
Guile's site directory.  In order to include this convenience
functionality you can <code>(use-modules (serveez-mg lib))</code> at the top
of the configuration file.

     <dl>
<dt><code>(interface-add! . interface)</code><dd>Add one more network interfaces to the list of known interfaces. You can
get the list of known interfaces by running &lsquo;<samp><span class="samp">serveez -i</span></samp>&rsquo;. The
<var>interface</var> argument must be in dotted decimal form
(e.g. 127.0.0.1). Serveez provides this function for systems where it is
unable to detect the list of network interface automatically.

     <!-- @item (loadpath-add! . path) -->
     <!-- Extends the load path for server modules by the path name @var{path}. -->
     <br><dt><code>(bind-servers! . args)</code><dd>This function is based upon <code>(bind-server!)</code>. It takes a list of port
configurations and servers and binds each to another.

     <br><dt><code>(bind-tcp-port-range! from to . servers)</code><dd>Bind the list of <var>servers</var> to simple TCP port configurations whose network
ports range between <var>from</var> and <var>to</var> both inclusive.

     <br><dt><code>(bind-udp-port-range! from to . servers)</code><dd>Bind the list of <var>servers</var> to simple UDP port configurations whose network
ports range between <var>from</var> and <var>to</var> both inclusive.

     <br><dt><code>(serveez-verbosity verbosity)</code><dd>Set the core library's logging verbosity to the <var>verbosity</var> level. Lesser
values mean fewer logging messages. This settings gets overridden by command
line.

     <br><dt><code>(serveez-maxsockets max)</code><dd>Set the number of maximum socket descriptors (number of concurrent
connections). When passing Serveez the -m command line argument this setting
gets overridden, too.

     <br><dt><code>(serveez-passwd password)</code><dd>Set the <var>password</var> for the control protocol. 
</dl>

<h4 class="subsection">6.5.1 Passthrough Server</h4>

<p>Another way to serve information in Serveez-MG is to use the passthrough
server.  The passthrough server lets you take a program that uses
<code>stdin</code> and <code>stdout</code> for input and output to server content
over a port.  Serveez-MG translates input and output from a port to the
<code>stdin</code> and <code>stdout</code> of the program.  In this way, it
functions like the internet daemon <code>inetd</code>.

<h5 class="subsubsection">6.5.1.1 General description</h5>

<p>The program passthrough server provides basic inetd functionality. 
Basically it can accept connections and pass this connection to the standard
input (stdin) and standard output (stdout) handles of programs.  Depending
on the platform (operating system) the user is able to configure different
methods how this can be achieved.

<h5 class="subsubsection">6.5.1.2 Configuration</h5>

<p>This server has different types of configuration options specifying its
behaviour.  Some of them are mandatory and some are optional.  The very
least to configure is the program to be started when a new connection is
made.

     <dl>
<dt><code>binary (string, no default)</code><dd>This parameter specifies the program to execute when a new connection
has been accepted.  The parameter is mandatory and must be a fully qualified
file name (including path).

     <br><dt><code>directory (string, no default)</code><dd>This will be the working directory of the executed program.  If you omit
this parameter the server uses the current directory (the directory is not
changed).

     <br><dt><code>user (string, no default)</code><dd>If you omit this parameter no user or group will be set for the
started program.  Otherwise you need to specify this information in the
format &lsquo;<samp><span class="samp">user[.group]</span></samp>&rsquo;.  If the group is omitted the user's primary
group will be used.

     <br><dt><code>argv (string array, no default)</code><dd>This list of character strings is going to be the program's argument list
(command line).  If the first list item (which is argv[0] and the program's
name) is left blank it defaults to the name specified in the
<code>binary</code> parameter.

     <br><dt><code>do-fork (boolean, default: true)</code><dd>This flag specifies the method used to pass the connection to the program. 
If it is true the server uses the Unix'ish <code>fork()</code> and <code>exec()</code>
method.  Otherwise it will pass the data through a unnamed pair of
sockets [ or two pairs of anonymous pipes ].

     <br><dt><code>single-threaded (boolean, default: true)</code><dd>This parameter applies to servers bound to UDP and ICMP port configurations
only.  For programs which process all incoming packets and eventually time
out, the program is said to be &lsquo;<samp><span class="samp">single-threaded</span></samp>&rsquo; and should use a true
value here.  If a program gets a packet and can receive further packets, it
is said to be a &lsquo;<samp><span class="samp">multi-threaded</span></samp>&rsquo; program, and should use a false value.

     <br><dt><code>thread-frequency (integer, default: 40)</code><dd>The optional <code>thread-frequency</code> parameter specifies the maximum number
of program instances that may be spawned from the server within an interval
of 60 seconds. 
</dl>

<div class="node">
<a name="Concept"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Server">Server</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Deploying">Deploying</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">7 Concept</h2>

<p>We now have a closer look at the internals of Serveez. You'll need
to understand this is you want to write your own server in Scheme.

<h3 class="section">7.1 Overall concept</h3>

<p>The primary functionality Serveez provides is a framework for Internet
services.  It can act as a kind of server collection and may even
replace super-servers such as the inetd daemon.

   <p>Its key features and benefits are:

     <ul>
<li>support for packet and connection oriented protocols<br>
Serveez currently supports two server types.  TCP and named pipe servers
are connection oriented servers.  This type of server accepts a client's
connection request and communicates with it using a dedicated
connection.  The format of the incoming and outgoing data streams are
irrelevant to Serveez.  Packet oriented servers (like UDP and ICMP)
receive data packets and respond to the sender with data packets.  A
server in Serveez can detect whether it is bound to a packet or
connection oriented port configuration and thus can act as the expected
type.

     <li>server and client functionality<br>
Besides a wide variety of server capabilities, Serveez also contains
some client functionality.  This may be necessary when a server is meant
to establish a connection to another server in response to an incoming
request.  For example, imagine a protocol where a client tells the
server "Let me be the server.  Please connect to this <var>host</var> at this
<var>port</var>.".  You are also able to implement pure clients.

     <li>complete lack of platform portability<br>
The original GNU Serveez was a miracle of platform portability.  This
version, Serveez-MG, is not.  It very specifically targets those
GNU/Linux distributions that are complient with the LSB 4.1
specification.

     <li>powerful configuration capabilities<br>
Server configuration has always been a complicated but very important
issue.  When Serveez starts up it runs the configuration file using the
programming language Guile.  In contradiction, other (server)
applications just read their configuration files and remember the
settings in it.  This makes them powerful enough to adapt the Serveez
settings dynamically.  Using the Guile interpreter also means that you
can split your configuration into separate files and load these, perhaps
conditionally, from the main configuration file.

     <li>easy server implementation<br>
Serveez is a server framework.  When implementing a new server the
programmer need pay little or no attention to the networking code but is
free to direct his attention to the protocol the server is meant to
support.  That protocol may be an established one such as HTTP, or may
be a custom protocol fitting the specific application's requirements.

     <li>code reusability<br>
The GNU Serveez package did come along with a core library and an API
for the C language which contained most of the functionality necessary
to write an Internet server.  Most probably, a programmer could also
use the library for other (network programming related) purposes. 
But, for this version, Serveez-MG, I've stripped out some of its
functionality, so the original GNU version might be better if you
actually wanted a core library.

     <p>This version does retain the Guile functionality, though.

     <li>server instantiation and network port sharing<br>
Once you have written a protocol server and integrated into Serveez's
concept of servers the user can instantiate (multiply) the server.  At
the first glimpse this sounds silly, but with different server
configurations it does not.  If, for example, an administrator wishes to
run multiple HTTP servers with different document roots, Serveez will
handle them all in a single process.  Also if the same administrator
wants to run a HTTP server and some other server on the same network
port this is possible with Serveez.  You can run a single server on
different network ports, too. 
</ul>

<h3 class="section">7.2 I/O Strategy</h3>

<p>Serveez-MG's I/O strategy is the traditional <code>poll()</code> function

<h4 class="subsection">7.2.1 Limits on open filehandles</h4>

<p>The limits set by <code>ulimit()</code> or <code>setrlimit()</code> affect the
performance of the servers.

<div class="node">
<a name="Server"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Coserver">Coserver</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Concept">Concept</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">8 Server</h2>

<ul class="menu">
<li><a accesskey="1" href="#Introduction-to-servers">Introduction to servers</a>:      Protocol servers in Serveez
<li><a accesskey="2" href="#Writing-servers">Writing servers</a>:              How to write Internet protocol servers
<li><a accesskey="3" href="#Configuring-servers">Configuring servers</a>:          How do I configure an existing server ? 
</ul>

<div class="node">
<a name="Introduction-to-servers"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Writing-servers">Writing servers</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Server">Server</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Server">Server</a>

</div>

<h3 class="section">8.1 Introduction to servers</h3>

<p>Serveez is a kind of server server. It allows different protocol
servers to listen on various TCP/UDP ports, on ICMP sockets and on named
pipes. Servers are instantiated with a certain configuration. It is
possible to run multiple different servers on the same port.

   <p>This chapter covers all questions about how to write your own Internet
protocol server with this package. Most of the common tasks of
such a server have got a generic solution (default routines) which could be
"overridden" by your own routines. There are some examples within this
package. They are showing the possibilities with this package and how to
implement servers.

   <p>The &lsquo;<samp><span class="samp">foo</span></samp>&rsquo; server does not do anything at all and is of no actual use
but could be a basis for a new protocol server. We are now going to describe
how this specific server works. Eventually the reader might get an
impression of what is going on.

   <p>For better understanding the text below we will use the following
terminology:
     <dl>
<dt>server definition<dd>A server definition is a <code>#&lt;svz-servertype&gt;</code> which contains
server specific members like its name, different callbacks, a single
default configuration and a list of configuration items which
determines what can be configured.

     <br><dt>server configuration<dd>A server configuration can be any kind of structure. The default server
configuration must be specified within the server definition (see above). 
When instantiating a server (which is done via the configuration file) the
configuration items specified in the server definition get processed and
are put into a copy of the default configuration. Thus we get an instance.

     <br><dt>server instance<dd>A server instance is a copy of the server definition including the modified
server configuration. A server gets instantiated by the configuration file
parser. The concept of server instances has been introduced because we
wanted Serveez to have the following features. A single server can have
multiple instances with different behaviour due to different server
configurations. A server instance can be bound to multiple port
configurations. Different server instances (of the same and/or different
server type) can share the same port configuration. 
</dl>

<div class="node">
<a name="Writing-servers"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Configuring-servers">Configuring servers</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Introduction-to-servers">Introduction to servers</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Server">Server</a>

</div>

<h3 class="section">8.2 Writing servers in Guile</h3>

<p>This section describes the Guile interface to Serveez which provides
the ability to write servers with Guile.  Of course, you could do this
without any help from Serveez, but it makes the task a lot easier. 
This interface reduces the Guile implementation of an Internet server
to a simple data processor.

<ul class="menu">
<li><a accesskey="1" href="#Guile-servers">Guile servers</a>:                Servers using Serveez's guile interface
</ul>

<div class="node">
<a name="Guile-servers"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Writing-servers">Writing servers</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Writing-servers">Writing servers</a>

</div>

<h4 class="subsection">8.2.1 Guile server functions reference manual</h4>

<!-- *-texinfo-*- -->
<!-- This file includes the documentation about the Guile servers.  It is -->
<!-- included by `serveez.texi'. -->
<p>This section describes the Guile interface to Serveez which provides
the ability to write servers with Guile.  Of course, you could do this
without any help from Serveez, but it makes the task a lot easier. 
This interface reduces the Guile implementation of an Internet server
to a simple data processor.

<h5 class="subsubsection">8.2.1.1 Special Data Types</h5>

<p>Serveez extends Guile by various new data types which represent internal
data structures of Serveez's core API.

     <ul>
<li><code>#&lt;svz-servertype&gt;</code>
represents a server type. 
<li><code>#&lt;svz-server&gt;</code>
represents a server (an instance of a server type). 
<li><code>#&lt;svz-socket&gt;</code>
represents a socket structure. 
</ul>

<h5 class="subsubsection">8.2.1.2 Passing Binary Data</h5>

<p>The bytevector data type provides access to any kind of unstructured
data.  It manages the data exchange between Guile and Serveez. 
Serveez-MG adds a few additional bytevector routines, for convenience.

<div class="defun">
&mdash; Function: <b>subbytevector</b><var> bv start end<a name="index-subbytevector-1"></a></var><br>
<blockquote><p>Create a new bytevector that is a copy of BV from START (inclusive)
to END (exclusive).

        <p>This procedure in the <code>(serveez-mg lib)</code> library. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: <b>bytevector-contains</b><var> bv1 bv2<a name="index-bytevector_002dcontains-2"></a></var><br>
<blockquote><p>Search for bytevector BV2 in bytevector BV1.  If it is found, return
the index in BV1 where BV2 is located.  Otherwise, return #f.

        <p>This procedure in the <code>(serveez-mg lib)</code> library. 
</p></blockquote></div>

<h5 class="subsubsection">8.2.1.3 Server Definition</h5>

<p>In order to set up a new server type, you use the procedure
<code>(define-servertype!)</code>.  This procedure takes one argument which
must be an associative list specifying the server type in detail.  There
are optional and mandatory elements you can set up in this alist.  Many
of the values in this association list will be scheme callback procedures
that will be called by Serveez-MG when needed.

   <p>The following example shows the overall syntax of this procedure:

<pre class="lisp">     (define-servertype! '(
     
       ;; Mandatory: server type prefix for later use in (define-server!)
       (prefix          . "foo")
     
       ;; Mandatory: server type description
       (description     . "guile foo server")
     
       ;; Mandatory for TCP and PIPE servers: protocol detection
       (detect-proto    . foo-detect-proto)
     
       ;; Optional: global server type initialisation
       (global-init     . foo-global-init)
     
       ;; Optional: server instance initialisation
       (init            . foo-init)
     
       ;; Optional: server instance finalisation
       (finalize        . foo-finalize)
     
       ;; Optional: global server type finalisation
       (global-finalize . foo-global-finalize)
     
       ;; Mandatory for TCP and PIPE servers: socket connection
       (connect-socket  . foo-connect-socket)
     
       ;; Optional: server instance info
       (info-server     . foo-info-server)
     
       ;; Optional: client info
       (info-client     . foo-info-client)
     
       ;; Optional: server instance reset callback
       (reset           . foo-reset)
     
       ;; Optional: server instance notifier
       (notify          . foo-notify)
     
       ;; Mandatory for UDP and ICMP servers: packet handler
       (handle-request  . foo-handle-request)
     
       ;; Mandatory: server type configuration (may be an empty list)
       (configuration   . (
     
         ;; The server configuration is an alist (associative list) again.
         ;; Each item consists of an item name and a list describing the
         ;; item itself.
         ;; Syntax: (key . (type defaultable default))
         (foo-integer       . (integer  #t 0))
         (foo-integer-array . (intarray #t (1 2 3 4 5)))
         (foo-string        . (string   #t "default-foo-string"))
         (foo-string-array  . (strarray #t ("guile" "foo" "server")))
         (foo-hash          . (hash     #t (("foo" . "bar"))))
         (foo-port          . (portcfg  #t foo-port))
         (foo-boolean       . (boolean  #t #t))
       ))))
</pre>
   <p>So, for each Guile server you want to create, you need to
write a few callback functions.  For a TCP or PIPE server you
must write, at a minimum, callback procedures for
     <dl>
<dt>&lsquo;<samp><span class="samp">detect-proto</span></samp>&rsquo;<dd>A protocol detection callback procedure.  The procedure takes two arguments:
a <code>#&lt;svz-server&gt;</code> and a <code>#&lt;svz-socket&gt;</code>. 
<br><dt>&lsquo;<samp><span class="samp">connect-socket</span></samp>&rsquo;<dd>A callback for the socket connection after successful detection.  It
also takes two arguments: a <code>#&lt;svz-server&gt;</code> and a
<code>#&lt;svz-socket&gt;</code>. 
<br><dt>&lsquo;<samp><span class="samp">configuration</span></samp>&rsquo;<dd>An association list of keys and values that offers an information store
specific to this server instance.  These values can be queries later
using the <code>svz:server:config-ref</code> procedure. 
</dl>

   <p>These elements are explained in more detail below

<!-- doc-snarfer [guile-server.c:1611] -->
<div class="defun">
&mdash; Function: <b>define-servertype!</b><var> args<a name="index-define_002dservertype_0021-3"></a></var><br>
<blockquote><p>Guile server definition: This procedure takes one argument containing
the information about a new server type.  If everything works fine you
have a freshly registered server type afterwards.  Return <code>#t</code> on
success. 
</p></blockquote></div>

<h5 class="subsubsection">8.2.1.4 Callback Prototypes</h5>

<p>The Guile interface of Serveez is completely callback driven. 
Callbacks can be set up in the associative list passed to
<code>(define-servertype!)</code>, or by using the predefined procedures
described in the previous section.  Each of the callbacks is passed
certain arguments and is meant to return specific values to indicate
success or failure.  This section describes each of these callbacks.

     <dl>
<dt><code>(global-init #&lt;svz-servertype&gt;)</code><dd>This callback is invoked once for every type of server right after
the <code>(define-servertype!)</code> statement.  Here you can initialise
resources shared between all instances of your server type.  The callback
is optional and can be set up in <code>(define-servertype!)</code>.  It should
return zero to indicate success and non-zero to indicate failure.  If the
global initialiser fails, Serveez will refuse to register the server type.

     <br><dt><code>(global-finalize #&lt;svz-servertype&gt;)</code><dd>If you want to free shared resources, which were possibly allocated
within the global initialiser, you can do so here.  The callback is
invoked when Serveez shuts down (issued by <code>(serveez-nuke)</code>) or the
server type gets unregistered for some reason.  It should return zero to
signal success.  The callback can be set up in <code>(define-servertype!)</code>
and is optional.

     <br><dt><code>(init #&lt;svz-server&gt;)</code><dd>Within this callback you can initialise everything you might need for
a single instance of your server.  The callback is invoked for each
server instance which has been created by <code>(define-server!)</code> and
should return zero to indicate success, otherwise Serveez rejects the
server instance.  The callback can be set up in <code>(define-servertype!)</code>
and is optional.

     <br><dt><code>(finalize #&lt;svz-server&gt;)</code><dd>The server instance finaliser gets its instance representation passed
as argument.  You need to free all resources used by this server
instance which might have been allocated within the server instance
initialiser or consumed while running.  You can set this callback in
the <code>(define-servertype!)</code> statement.  The callback is optional
and should return zero to indicate success.

     <br><dt><code>(detect-proto #&lt;svz-server&gt; #&lt;svz-socket&gt;)</code><dd>Connection oriented protocols like TCP and PIPE allow more than one
server to be listening on the same network port.  Therefore, it is
necessary to be able to detect the type of client connecting to a port.

     <p>This callback takes two arguments; the first is the server instance
and the second is the client socket object containing the client
connection information.  You can set up this callback in the
<code>(define-servertype!)</code> statement.

     <p>Serveez may invoke this callback several times as data becomes
available from the client until one of the servers recognises it. 
The servers can retrieve the data received so far using the
<code>(svz:sock:receive-buffer)</code> call.

     <p>To indicate successful client detection, you need to return a non-zero
value.  (Note that for historical reasons, this is inconsistent with
other functions which return zero on successful completion.)  Once the
server has indicated success, Serveez invokes any further callbacks for
the connection only on that server.

     <p>If no server has recognised the client after the first 16 bytes, Serveez
will close the connection.  The connection will also be closed if the
client has not sent enough data for a server to recognise it within 30
seconds of connecting.

     <p>If multiple servers are listening on the same network port, Serveez
invokes this callback for each of them in an arbitrary order.  Only one
server at most should indicate successful detection.

     <p>This callback is mandatory for servers which get bound to
connection oriented protocol (TCP and PIPE) port configurations by
<code>(bind-server!)</code>.

     <br><dt><code>(connect-socket #&lt;svz-server&gt; #&lt;svz-socket&gt;)</code><dd>If the client detection signalled success, this callback is invoked to
assign the client connection to a server instance.  The arguments are
the same as the detection callback.  In this callback you can assign
all the connection specific callbacks for your server and perform some
initial tasks.  Basically you should specify the <code>handle-request</code>
and/or <code>check-request</code> callback.  This can be achieved by calling
<code>(svz:sock:handle-request)</code> and <code>(svz:sock:check-request)</code>. 
The <code>connect-socket</code> callback is also mandatory for connection
oriented protocols and must be defined in <code>(define-servertype!)</code>. 
On success you should return zero, otherwise the connection will be
shutdown by Serveez.

     <br><dt><code>(info-server #&lt;svz-server&gt;)</code><dd>This callback gets invoked when requested by the builtin
<code>Control Protocol Server</code>.  The callback is optional and can be
set up in <code>(define-servertype!)</code>.  The returned character string
can be multiple lines separated by <code>\r\n</code> (but without a trailing
separator).  Usually you will return information about the server instance
configuration and/or state.

     <br><dt><code>(info-client #&lt;svz-server&gt; #&lt;svz-socket&gt;)</code><dd>This callback is optional.  You can set it up in the
<code>(define-servertype!)</code> procedure.  It is meant to provide socket
structure specific information.  (The socket structure is a client/child
of the given server instance.)  You need to return a single line
character string without trailing newlines.  The information provided
can be requested by the builtin <code>Control Protocol Server</code>.

     <br><dt><code>(notify #&lt;svz-server&gt;)</code><dd>The server instance notifier callback will be invoked whenever there is idle
time available.  In practice, it is run approximately once a second. 
A server instance can use it to perform periodic tasks.  The callback
is optional and can be set up in <code>(define-servertype!)</code>.

     <br><dt><code>(reset #&lt;svz-server&gt;)</code><dd>This callback is invoked when the Serveez process receives a <code>SIGHUP</code>
signal which can be issued via &lsquo;<samp><span class="samp">killall -HUP serveez</span></samp>&rsquo; from user
land.  If the underlying operating system does not provide <code>SIGHUP</code>
there is no use for this callback.  It provides the possibility to
perform asynchronous tasks scheduled from outside Serveez.  You can
optionally set it up in the <code>(define-servertype!)</code> procedure.

     <br><dt><code>(handle-request #&lt;svz-socket&gt; #&lt;bytevector&gt; size)</code><dd>This callback is invoked whenever a complete packet has been detected
in the receive buffer.  The packet data is passed to the callback as a
<code>bytevector</code>.  The <var>size</var> argument is passed for convenience
and specifies the length of the packet in bytes.

     <p>The detection, and therefore the invocation, can be made in one of two
ways.  When Serveez can determine itself when a packet is complete, the
callback will be invoked directly.  Serveez can make this determination
for connections with packet oriented protocols such as UDP and ICMP, or
if you tell Serveez how to parse the packet using
<code>(svz:sock:boundary sock delimiter)</code> or
<code>(svz:sock:boundary sock size)</code> and do not specify a
<code>check-request</code> callback.

     <p>Whenever you specify a <code>check-request</code> callback to determine when
a packet is complete, it becomes the responsiblity of that callback to
invoke <code>handle-request</code> itself.

     <p>Serveez recognises two different return value meanings.  For connection
oriented protocols (TCP and PIPE), zero indicates success and non-zero
failure; on failure, Serveez will shutdown the connection.  For packet
oriented protocols (UDP and ICMP), a non-zero return value indicates
that your server was able to process the passed packet data, otherwise
(zero return value) the packet can be passed to other servers listening
on the same port configuration.

     <p>This callback must be specified in <code>(define-servertype!)</code> for
packet oriented protocols (UDP and ICMP) but is optional otherwise. 
You can modify the callback by calling <code>(svz:sock:handle-request)</code>.

     <br><dt><code>(check-request #&lt;svz-socket&gt;)</code><dd>This callback is invoked whenever new data has arrived in the receive buffer. 
The receive buffer of the given <code>#&lt;svz-socket&gt;</code> can be obtained
using <code>(svz:sock:receive-buffer)</code>.  The callback is initially not
set and can be set up with <code>(svz:sock:check-request)</code>.  Its purpose
is to check whether a complete request was received.  If so, it should
be handled (by running the <code>handle-request</code> callback) and removed
from the receive buffer (using <code>(svz:sock:receive-buffer-reduce)</code>). 
The callback is for connection oriented protocols (TCP and PIPE) only. 
You should return zero to indicate success and non-zero to indicate
failure.  On failure Serveez shuts the connection down.

     <br><dt><code>(disconnected #&lt;svz-socket&gt;)</code><dd>The <code>disconnected</code> callback gets invoked whenever the socket is
lost for some external reason and is going to be shutdown by Serveez. 
It can be set up with <code>(svz:sock:disconnected)</code>.

     <br><dt><code>(kicked #&lt;svz-socket&gt; reason)</code><dd>This callback gets invoked whenever the socket gets closed by Serveez
intentionally.  It can be set up with <code>(svz:sock:kicked)</code>.  The
<var>reason</var> argument can be either <code>KICK_FLOOD</code>, indicating the
socket is a victim of the builtin flood protection, or <code>KICK_QUEUE</code>
which indicates a send buffer overflow.

     <br><dt><code>(idle #&lt;svz-socket&gt;)</code><dd>The <code>idle</code> callback gets invoked from the periodic task scheduler,
which maintains a <code>idle-counter</code> for each socket structure. 
This counter is decremented whenever Serveez becomes idle and the
callback is invoked when it drops to zero.  The <code>idle</code> callback can
set its socket's <code>idle-counter</code> to some value with the procedure
<code>(svz:sock:idle-counter)</code> and thus re-schedule itself for a later
task.  You can set up this callback with <code>(svz:sock:idle)</code>.

     <br><dt><code>(trigger-condition #&lt;svz-socket&gt;)</code><dd>This callback is invoked once every server loop for the socket structure. 
If you return <code>#f</code> nothing else is happening.  Otherwise the
<code>trigger</code> callback will be invoked immediately.  You can set up the
callback using the procedure <code>(svz:sock:trigger-condition)</code>.

     <br><dt><code>(trigger #&lt;svz-socket&gt;)</code><dd>The <code>trigger</code> callback is invoked when the <code>trigger-condition</code>
returns <code>#t</code>.  The callback can be set up with the procedure
<code>(svz:sock:trigger)</code>.  Returning a non-zero value shuts the
connection down.  A zero return value indicates success.  This callback
can be used to perform connection related updates, e.g. you can ensure
a certain send buffer fill.

     <br><dt><code>(check-oob-request #&lt;svz-socket&gt; oob-byte)</code><dd>This callback is invoked whenever urgent data (out-of-band) has been detected
on a socket.  Initially this event is ignored and the callback can be set
up with the procedure <code>(svz:sock:check-oob-request)</code>.  The
<var>oob-byte</var> argument is a number containing the received out-of-band
data byte ranging from 0 to 255.  If the callback returns non-zero the
connection will be shutdown.  A zero return value indicates success.  You
can use <code>(svz:sock:send-oob)</code> to send a single out-of-band data byte. 
</dl>

<h5 class="subsubsection">8.2.1.5 Predefined Procedures</h5>

<p>The following set of procedures may be useful for implementing a Guile
server.  They should be used within the callbacks defined in the
<code>(define-servertype!)</code> procedure.  Each of these callbacks gets
passed the appropriate arguments needed to stuff into the following
procedures.

<!-- doc-snarfer [guile-api.c:471] -->
<div class="defun">
&mdash; Function: <b>svz:sock?</b><var> sock<a name="index-svz_003asock_003f-4"></a></var><br>
<blockquote><p>Returns <code>#t</code> if the given cell <var>sock</var> is an instance of a valid
<code>#&lt;svz-socket&gt;</code>, otherwise <code>#f</code>. 
</p></blockquote></div>

<!-- doc-snarfer [guile-server.c:893] -->
<div class="defun">
&mdash; Function: <b>svz:sock:check-request</b><var> sock proc<a name="index-svz_003asock_003acheck_002drequest-5"></a></var><br>
<blockquote><p>Set the <code>check-request</code> member of the socket structure <var>sock</var>
to the Guile procedure <var>proc</var>.  Returns the previously handler if
there is any. 
</p></blockquote></div>

<!-- doc-snarfer [guile-api.c:554] -->
<div class="defun">
&mdash; Function: <b>svz:sock:check-oob-request</b><var> sock proc<a name="index-svz_003asock_003acheck_002doob_002drequest-6"></a></var><br>
<blockquote><p>With this procedure you can setup the <code>check-oob-request</code> callback
of the given socket structure <var>sock</var>.  The previous callback is
replaced by the <var>proc</var> procedure and will be returned if there was
set any before.  The callback is run whenever urgent data (out-of-band)
has been detected on the socket. 
</p></blockquote></div>

<!-- doc-snarfer [guile-api.c:929] -->
<div class="defun">
&mdash; Function: <b>svz:sock:send-oob</b><var> sock oob<a name="index-svz_003asock_003asend_002doob-7"></a></var><br>
<blockquote><p>This procedure expects a TCP <code>#&lt;svz-socket&gt;</code> in <var>sock</var> and an
exact number or single character in <var>oob</var>.  The byte in <var>oob</var>
is sent as urgent (out-of-band) data through the underlying TCP stream. 
The procedure returns <code>#t</code> on successful completion and otherwise
(either it failed to send the byte or the passed socket is not a TCP
socket) <code>#f</code>. 
</p></blockquote></div>

<!-- doc-snarfer [guile-server.c:884] -->
<div class="defun">
&mdash; Function: <b>svz:sock:handle-request</b><var> sock proc<a name="index-svz_003asock_003ahandle_002drequest-8"></a></var><br>
<blockquote><p>Set the <code>handle-request</code> member of the socket structure <var>sock</var>
to the Guile procedure <var>proc</var>.  The procedure returns the previously
set handler if there is any. 
</p></blockquote></div>

<!-- doc-snarfer [guile-server.c:909] -->
<div class="defun">
&mdash; Function: <b>svz:sock:boundary</b><var> sock boundary<a name="index-svz_003asock_003aboundary-9"></a></var><br>
<blockquote><p>Setup the packet boundary of the socket <var>sock</var>.  The given string value
<var>boundary</var> can contain any kind of data.  If you pass an exact number
value the socket is setup to parse fixed sized packets.  In fact this
procedure sets the <code>check-request</code> callback of the given socket
structure <var>sock</var> to a predefined routine which runs the
<code>handle-request</code> callback of the same socket when it detected a
complete packet specified by <var>boundary</var>.  For instance you
can setup Serveez to pass your <code>handle-request</code> procedure text lines
by calling <code>(svz:sock:boundary sock "\n")</code>. 
</p></blockquote></div>

<!-- doc-snarfer [guile-server.c:948] -->
<div class="defun">
&mdash; Function: <b>svz:sock:floodprotect</b><var> sock flag<a name="index-svz_003asock_003afloodprotect-10"></a></var><br>
<blockquote><p>Set or unset the flood protection bit of the given socket <var>sock</var>. 
Returns the previous value of this bit (#t or #f).  The <var>flag</var>
argument must be either boolean or an exact number and is optional. 
</p></blockquote></div>

<!-- doc-snarfer [guile-server.c:975] -->
<div class="defun">
&mdash; Function: <b>svz:sock:print</b><var> sock buffer<a name="index-svz_003asock_003aprint-11"></a></var><br>
<blockquote><p>Write the string buffer <var>buffer</var> to the socket <var>sock</var>.  The
procedure accepts binary smobs too.  Return <code>#t</code> on success and
<code>#f</code> on failure. 
</p></blockquote></div>

<!-- doc-snarfer [guile-api.c:423] -->
<div class="defun">
&mdash; Function: <b>svz:sock:final-print</b><var> sock<a name="index-svz_003asock_003afinal_002dprint-12"></a></var><br>
<blockquote><p>This procedure schedules the socket <var>sock</var> for shutdown after all data
within the send buffer queue has been sent.  The user should issue this
procedure call right *before* the last call to <code>(svz:sock:print)</code>. 
</p></blockquote></div>

<!-- doc-snarfer [guile-api.c:441] -->
<div class="defun">
&mdash; Function: <b>svz:sock:no-delay</b><var> sock enable<a name="index-svz_003asock_003ano_002ddelay-13"></a></var><br>
<blockquote><p>Turns the Nagle algorithm for the TCP socket <var>sock</var> on or off depending
on the optional <var>enable</var> argument.  Returns the previous state of this
flag (<code>#f</code> if Nagle is active, <code>#t</code> otherwise).  By default this
flag is switched off.  This socket option is useful when dealing with small
packet transfer in order to disable unnecessary delays. 
</p></blockquote></div>

<!-- doc-snarfer [guile-api.c:199] -->
<div class="defun">
&mdash; Function: <b>svz:sock:send-buffer</b><var> sock<a name="index-svz_003asock_003asend_002dbuffer-14"></a></var><br>
<blockquote><p>Return the send buffer of the socket <var>sock</var> as a binary smob. 
</p></blockquote></div>

<!-- doc-snarfer [guile-api.c:219] -->
<div class="defun">
&mdash; Function: <b>svz:sock:send-buffer-size</b><var> sock size<a name="index-svz_003asock_003asend_002dbuffer_002dsize-15"></a></var><br>
<blockquote><p>This procedure returns the current send buffer size and fill status in
bytes of the socket <var>sock</var> as a pair of exact numbers.  If the
optional argument <var>size</var> is given the send buffer will be set to
the specified size in bytes. 
</p></blockquote></div>

<!-- doc-snarfer [guile-api.c:157] -->
<div class="defun">
&mdash; Function: <b>svz:sock:receive-buffer</b><var> sock<a name="index-svz_003asock_003areceive_002dbuffer-16"></a></var><br>
<blockquote><p>Return the receive buffer of the socket <var>sock</var> as a bytevector. 
</p></blockquote></div>

<!-- doc-snarfer [guile-api.c:178] -->
<div class="defun">
&mdash; Function: <b>svz:sock:receive-buffer-size</b><var> sock size<a name="index-svz_003asock_003areceive_002dbuffer_002dsize-17"></a></var><br>
<blockquote><p>Returns the current receive buffers size and fill status in bytes of
the socket <var>sock</var> as a pair of exact numbers.  If the optional
argument <var>size</var> is given the receive buffer will be set to the
specified size in bytes. 
</p></blockquote></div>

<!-- doc-snarfer [guile-api.c:243] -->
<div class="defun">
&mdash; Function: <b>svz:sock:receive-buffer-reduce</b><var> sock length<a name="index-svz_003asock_003areceive_002dbuffer_002dreduce-18"></a></var><br>
<blockquote><p>Dequeue <var>length</var> bytes from the receive buffer of the socket
<var>sock</var> which must be a valid <code>#&lt;svz-socket&gt;</code>.  If the user omits
the optional <var>length</var> argument, all of the data in the receive buffer
gets dequeued.  Returns the number of bytes actually shuffled away. 
</p></blockquote></div>

<!-- doc-snarfer [guile-api.c:82] -->
<div class="defun">
&mdash; Function: <b>svz:sock:connect</b><var> host proto port<a name="index-svz_003asock_003aconnect-19"></a></var><br>
<blockquote><p>Establishes a network connection to the given <var>host</var> [ :<var>port</var> ]. 
If <var>proto</var> equals <code>PROTO_ICMP</code> the <var>port</var> argument is
ignored.  Valid identifiers for <var>proto</var> are <code>PROTO_TCP</code>,
<code>PROTO_UDP</code> and <code>PROTO_ICMP</code>.  The <var>host</var> argument must be
either a string in dotted decimal form, a valid hostname or an exact number
in host byte order.  When giving a hostname this operation might be
blocking.  The <var>port</var> argument must be an exact number in the range from
0 to 65535, also in host byte order.  Returns a valid <code>#&lt;svz-socket&gt;</code>
or <code>#f</code> on failure. 
</p></blockquote></div>

<!-- doc-snarfer [guile-api.c:498] -->
<div class="defun">
&mdash; Function: <b>svz:sock:disconnected</b><var> sock proc<a name="index-svz_003asock_003adisconnected-20"></a></var><br>
<blockquote><p>Set the <code>disconnected-socket</code> member of the socket structure
<var>sock</var> to the Guile procedure <var>proc</var>.  The given callback
runs whenever the socket is lost for some external reason.  The procedure
returns the previously set handler if there is one. 
</p></blockquote></div>

<!-- doc-snarfer [guile-api.c:509] -->
<div class="defun">
&mdash; Function: <b>svz:sock:kicked</b><var> sock proc<a name="index-svz_003asock_003akicked-21"></a></var><br>
<blockquote><p>Sets the <code>kicked-socket</code> callback of the given socket structure
<var>sock</var> to the Guile procedure <var>proc</var> and returns any previously
set procedure.  This callback gets called whenever the socket gets
closed by Serveez intentionally. 
</p></blockquote></div>

<!-- doc-snarfer [guile-api.c:530] -->
<div class="defun">
&mdash; Function: <b>svz:sock:trigger</b><var> sock proc<a name="index-svz_003asock_003atrigger-22"></a></var><br>
<blockquote><p>Sets the <code>trigger</code> callback of the socket structure <var>sock</var> to
the Guile procedure <var>proc</var> and returns any previously set procedure. 
The callback is run when the <code>trigger-condition</code> callback returned
<code>#t</code>. 
</p></blockquote></div>

<!-- doc-snarfer [guile-api.c:520] -->
<div class="defun">
&mdash; Function: <b>svz:sock:trigger-condition</b><var> sock proc<a name="index-svz_003asock_003atrigger_002dcondition-23"></a></var><br>
<blockquote><p>This procedure sets the <code>trigger-condition</code> callback for the socket
structure <var>sock</var> to the Guile procedure <var>proc</var>.  It returns the
previously set procedure if available.  The callback is run once every
server loop indicating whether the <code>trigger</code> callback should be
run or not. 
</p></blockquote></div>

<!-- doc-snarfer [guile-api.c:543] -->
<div class="defun">
&mdash; Function: <b>svz:sock:idle</b><var> sock proc<a name="index-svz_003asock_003aidle-24"></a></var><br>
<blockquote><p>This procedure sets the <code>idle</code> callback of the socket structure
<var>sock</var> to the Guile procedure <var>proc</var>.  It returns any previously
set procedure.  The callback is run by the periodic task scheduler when the
<code>idle-counter</code> of the socket structure drops to zero.  If this counter
is not zero it gets decremented once a second.  The <code>idle</code>
callback can reset <code>idle-counter</code> to some value and thus can
re-schedule itself for a later task. 
</p></blockquote></div>

<!-- doc-snarfer [guile-api.c:566] -->
<div class="defun">
&mdash; Function: <b>svz:sock:idle-counter</b><var> sock counter<a name="index-svz_003asock_003aidle_002dcounter-25"></a></var><br>
<blockquote><p>This functions returns the socket structure <var>sock</var>'s current
<code>idle-counter</code> value.  If the optional argument <var>counter</var> is
given, the function sets the <code>idle-counter</code>.  Please have a look at the
<code>(svz:sock:idle)</code> procedure for the exact meaning of this value. 
</p></blockquote></div>

<!-- doc-snarfer [guile-server.c:1024] -->
<div class="defun">
&mdash; Function: <b>svz:sock:data</b><var> sock data<a name="index-svz_003asock_003adata-26"></a></var><br>
<blockquote><p>Associate any kind of data (any Guile object) given in the argument
<var>data</var> with the socket <var>sock</var>.  The <var>data</var> argument is
optional.  The procedure always returns a previously stored value or an
empty list. 
</p></blockquote></div>

<!-- doc-snarfer [guile-api.c:329] -->
<div class="defun">
&mdash; Function: <b>svz:sock:parent</b><var> sock parent<a name="index-svz_003asock_003aparent-27"></a></var><br>
<blockquote><p>Return the given socket's <var>sock</var> parent and optionally set it to the
socket <var>parent</var>.  The procedure returns either a valid
<code>#&lt;svz-socket&gt;</code> object or an empty list. 
</p></blockquote></div>

<!-- doc-snarfer [guile-api.c:353] -->
<div class="defun">
&mdash; Function: <b>svz:sock:referrer</b><var> sock referrer<a name="index-svz_003asock_003areferrer-28"></a></var><br>
<blockquote><p>Return the given socket's <var>sock</var> referrer and optionally set it to the
socket <var>referrer</var>.  The procedure returns either a valid
<code>#&lt;svz-socket&gt;</code> or an empty list. 
</p></blockquote></div>

<!-- doc-snarfer [guile-api.c:381] -->
<div class="defun">
&mdash; Function: <b>svz:sock:server</b><var> sock server<a name="index-svz_003asock_003aserver-29"></a></var><br>
<blockquote><p>This procedure returns the <code>#&lt;svz-server&gt;</code> object associated with the
given argument <var>sock</var>.  The optional argument <var>server</var> can be used
to redefine this association and must be a valid <code>#&lt;svz-server&gt;</code>
object.  For a usual socket callback like <code>connect-socket</code> or
<code>handle-request</code>, the association is already in place.  But for sockets
created by <code>(svz:sock:connect)</code>, you can use it in order to make the
returned socket object part of a server. 
</p></blockquote></div>

<!-- doc-snarfer [guile-api.c:301] -->
<div class="defun">
&mdash; Function: <b>svz:sock:local-address</b><var> sock address<a name="index-svz_003asock_003alocal_002daddress-30"></a></var><br>
<blockquote><p>This procedure returns the current local address as a pair like
<code>(host .  port)</code> with both entries in network byte order.  If you pass
the optional argument <var>address</var>, you can set the local address of
the socket <var>sock</var>. 
</p></blockquote></div>

<!-- doc-snarfer [guile-api.c:272] -->
<div class="defun">
&mdash; Function: <b>svz:sock:remote-address</b><var> sock address<a name="index-svz_003asock_003aremote_002daddress-31"></a></var><br>
<blockquote><p>This procedure returns the current remote address as a pair like
<code>(host .  port)</code> with both entries in network byte order.  If you pass
the optional argument <var>address</var>, you can set the remote address of
the socket <var>sock</var>. 
</p></blockquote></div>

<!-- doc-snarfer [guile-api.c:833] -->
<div class="defun">
&mdash; Function: <b>svz:sock:find</b><var> ident<a name="index-svz_003asock_003afind-32"></a></var><br>
<blockquote><p>The given argument <var>ident</var> must be a pair of numbers where the
car is a <code>#&lt;svz-socket&gt;</code>'s identification number and the cdr the
version number.  The procedure returns either the identified
<code>#&lt;svz-socket&gt;</code> or <code>#f</code> if the given combination is not
valid anymore. 
</p></blockquote></div>

<!-- doc-snarfer [guile-api.c:857] -->
<div class="defun">
&mdash; Function: <b>svz:sock:ident</b><var> sock<a name="index-svz_003asock_003aident-33"></a></var><br>
<blockquote><p>This procedure returns a pair of numbers identifying the given
<code>#&lt;svz-socket&gt;</code> <var>sock</var> which can be passed to
<code>(svz:sock:find)</code>.  This may be necessary when you are passing
a <code>#&lt;svz-socket&gt;</code> through coserver callback arguments in order to
verify that the passed <code>#&lt;svz-socket&gt;</code> is still valid when the
coserver callback runs. 
</p></blockquote></div>

<!-- doc-snarfer [guile-api.c:408] -->
<div class="defun">
&mdash; Function: <b>svz:sock:protocol</b><var> sock<a name="index-svz_003asock_003aprotocol-34"></a></var><br>
<blockquote><p>Returns one of the <code>PROTO_TCP</code>, <code>PROTO_UDP</code>, <code>PROTO_ICMP</code>,
<code>PROTO_RAW</code> or <code>PROTO_PIPE</code> constants indicating the type of
the socket structure <var>sock</var>.  If there is no protocol information
available the procedure returns <code>#f</code>. 
</p></blockquote></div>

<!-- doc-snarfer [guile-api.c:875] -->
<div class="defun">
&mdash; Function: <b>svz:read-file</b><var> port size<a name="index-svz_003aread_002dfile-35"></a></var><br>
<blockquote><p>This procedure returns either a bytevector containing a data block read
from the open input port <var>port</var> with a maximum number of <var>size</var>
bytes or the end-of-file object if the underlying ports end has been
reached.  The size of the returned bytevector may be less than the
requested size <var>size</var> if it exceed the current size of the given port
<var>port</var>.  The procedure throws an exception if an error occurred while
reading from the port. 
</p></blockquote></div>

<!-- doc-snarfer [guile-api.c:484] -->
<div class="defun">
&mdash; Function: <b>svz:server?</b><var> server<a name="index-svz_003aserver_003f-36"></a></var><br>
<blockquote><p>Returns <code>#t</code> if the given cell <var>server</var> is an instance of a valid
<code>#&lt;svz-server&gt;</code>, otherwise <code>#f</code>. 
</p></blockquote></div>

<!-- doc-snarfer [guile-api.c:588] -->
<div class="defun">
&mdash; Function: <b>svz:server:listeners</b><var> server<a name="index-svz_003aserver_003alisteners-37"></a></var><br>
<blockquote><p>Returns a list of listening <code>#&lt;svz-socket&gt;</code> smobs to which the
given server instance <var>server</var> is currently bound, or an empty list
if there is no such binding yet. 
</p></blockquote></div>

<!-- doc-snarfer [guile-api.c:630] -->
<div class="defun">
&mdash; Function: <b>svz:server:clients</b><var> server<a name="index-svz_003aserver_003aclients-38"></a></var><br>
<blockquote><p>Returns a list of <code>#&lt;svz-socket&gt;</code> client smobs associated with
the given server instance <var>server</var> in arbitrary order, or an
empty list if there is no such client. 
</p></blockquote></div>

<!-- doc-snarfer [guile-server.c:1114] -->
<div class="defun">
&mdash; Function: <b>svz:server:config-ref</b><var> server key<a name="index-svz_003aserver_003aconfig_002dref-39"></a></var><br>
<blockquote><p>This procedure returns the configuration item specified by <var>key</var> of
the given server instance <var>server</var>.  You can pass this function a
socket too.  In this case the procedure will lookup the appropriate server
instance itself.  If the given string <var>key</var> is invalid (not defined
in the configuration alist in <code>(define-servertype!)</code>) then it returns
an empty list. 
</p></blockquote></div>

<!-- doc-snarfer [guile-server.c:1180] -->
<div class="defun">
&mdash; Function: <b>svz:server:state-set!</b><var> server key value<a name="index-svz_003aserver_003astate_002dset_0021-40"></a></var><br>
<blockquote><p>Associates the Guile object <var>value</var> with the string <var>key</var>.  The
given <var>server</var> argument can be both, a <code>#&lt;svz-server&gt;</code> or a
<code>#&lt;svz-socket&gt;</code>.  Returns the previously associated object or an
empty list if there was no such association.  This procedure is useful
for server instance state savings. 
</p></blockquote></div>

<!-- doc-snarfer [guile-server.c:1154] -->
<div class="defun">
&mdash; Function: <b>svz:server:state-ref</b><var> server key<a name="index-svz_003aserver_003astate_002dref-41"></a></var><br>
<blockquote><p>Returns the Guile object associated with the string value <var>key</var> which
needs to be set via <code>(svz:server:state-set!)</code> previously.  Otherwise
the return value is an empty list.  The given <var>server</var> argument must be
either a valid <code>#&lt;svz-server&gt;</code> object or a <code>#&lt;svz-socket&gt;</code>. 
</p></blockquote></div>

<!-- doc-snarfer [guile-server.c:1213] -->
<div class="defun">
&mdash; Function: <b>svz:server:state-&gt;hash</b><var> server<a name="index-svz_003aserver_003astate_002d_003ehash-42"></a></var><br>
<blockquote><p>Converts the <var>server</var> instance's state into a Guile hash. 
Returns an empty list if there is no such state yet. 
</p></blockquote></div>

<!-- doc-snarfer [guile.c:1528] -->
<div class="defun">
&mdash; Function: <b>serveez-port?</b><var> name<a name="index-serveez_002dport_003f-43"></a></var><br>
<blockquote><p>Returns <code>#t</code> if the given string <var>name</var> corresponds with a
registered port configuration, otherwise the procedure returns
<code>#f</code>. 
</p></blockquote></div>

<!-- doc-snarfer [guile.c:1534] -->
<div class="defun">
&mdash; Function: <b>serveez-server?</b><var> name<a name="index-serveez_002dserver_003f-44"></a></var><br>
<blockquote><p>Checks whether the given string <var>name</var> corresponds with an
instantiated server name and returns <code>#t</code> if so. 
</p></blockquote></div>

<!-- doc-snarfer [guile.c:1541] -->
<div class="defun">
&mdash; Function: <b>serveez-servertype?</b><var> name<a name="index-serveez_002dservertype_003f-45"></a></var><br>
<blockquote><p>This procedure checks whether the given string <var>name</var> is a valid
server type prefix known in Serveez and returns <code>#t</code> if so. 
Otherwise it returns <code>#f</code>. 
</p></blockquote></div>

<!-- doc-snarfer [guile-server.c:297] -->
<div class="defun">
&mdash; Function: <b>serveez-exceptions</b><var> enable<a name="index-serveez_002dexceptions-46"></a></var><br>
<blockquote><p>Controls the use of exceptions handlers for the Guile procedure calls
of Guile server callbacks.  If the optional argument <var>enable</var> set to
<code>#t</code> exception handling is enabled and if set to <code>#f</code>
exception handling is disabled.  The procedure always returns the
current value of this behaviour. 
</p></blockquote></div>

<!-- doc-snarfer [guile-server.c:281] -->
<div class="defun">
&mdash; Function: <b>serveez-nuke</b><var><a name="index-serveez_002dnuke-47"></a></var><br>
<blockquote><p>This procedure can be used to schedule Serveez for shutdown within Guile. 
Serveez will shutdown all network connections and terminate after the next
event loop.  You should use this instead of issuing <code>(quit)</code>. 
</p></blockquote></div>

<!-- @c doc-snarfer [guile.c:1643] -->
<!-- @defun serveez-load file -->
<!-- This procedure can be used as a replacement for @code{(primitive-load)} -->
<!-- in serveez configuration files.  It tries to locate the given filename -->
<!-- @var{file} in the paths returned by @code{(serveez-loadpath)}.  If -->
<!-- @var{file} cannot be loaded the procedure returns @code{#f}. -->
<!-- @end defun -->
<!-- @c doc-snarfer [guile.c:1485] -->
<!-- @defun serveez-loadpath args -->
<!-- Make the search path for the Serveez core library accessible for Guile. -->
<!-- Returns a list a each path as previously defined.  Can override the current -->
<!-- definition of this load path.  The load path is used to tell Serveez where -->
<!-- it can find additional server modules. -->
<!-- @end defun -->
<!-- doc-snarfer [guile.c:1432] -->
<div class="defun">
&mdash; Function: <b>serveez-interfaces</b><var> args<a name="index-serveez_002dinterfaces-48"></a></var><br>
<blockquote><p>Returns the local interfaces as a list of ip addresses in dotted decimal
form.  If another list is given in <var>args</var> it should contain the new
list of local interfaces. It will make the list of local interfaces
accessible for Guile. 
</p></blockquote></div>

<!-- doc-snarfer [guile-api.c:676] -->
<div class="defun">
&mdash; Function: <b>portmap</b><var> prognum versnum protocol port<a name="index-portmap-49"></a></var><br>
<blockquote><p>A user interface to the portmap service, which establishes a mapping
between the triple [<var>prognum</var>,<var>versnum</var>,<var>protocol</var>] and
<var>port</var> on the machine's portmap service.  The value of <var>protocol</var>
is most likely <code>IPPROTO_UDP</code> or <code>IPPROTO_TCP</code>. 
If the user omits <var>protocol</var> and <var>port</var>, the procedure destroys
all mapping between the triple [<var>prognum</var>,<var>versnum</var>,*] and ports
on the machine's portmap service. 
</p></blockquote></div>

<!-- doc-snarfer [guile-api.c:740] -->
<div class="defun">
&mdash; Function: <b>svz:coserver:dns</b><var> host callback arg<a name="index-svz_003acoserver_003adns-50"></a></var><br>
<blockquote><p>This procedure enqueues the <var>host</var> string argument into the internal
DNS coserver queue.  When the coserver responds, the Guile procedure
<var>callback</var> is run as <code>(callback addr arg)</code>.  The <var>addr</var>
argument passed to the callback is a string representing the appropriate
IP address for the given hostname <var>host</var>.  If you omit the optional
argument <var>arg</var> it is run as <code>(callback addr)</code> only.  The <var>arg</var>
argument may be necessary if you need to have the callback procedure
in a certain context. 
</p></blockquote></div>

<!-- doc-snarfer [guile-api.c:773] -->
<div class="defun">
&mdash; Function: <b>svz:coserver:reverse-dns</b><var> addr callback arg<a name="index-svz_003acoserver_003areverse_002ddns-51"></a></var><br>
<blockquote><p>This Guile procedure enqueues the given <var>addr</var> argument which must be
an IP address in network byte order into the internal reverse DNS coserver
queue.  When the coserver responds, the Guile procedure <var>callback</var> is
run as <code>(callback host arg)</code> where <var>host</var> is the hostname of the
requested IP address <var>addr</var>.  The last argument <var>arg</var> is
optional. 
</p></blockquote></div>

<!-- doc-snarfer [guile-api.c:804] -->
<div class="defun">
&mdash; Function: <b>svz:coserver:ident</b><var> sock callback arg<a name="index-svz_003acoserver_003aident-52"></a></var><br>
<blockquote><p>This procedure enqueues the given <code>#&lt;svz-socket&gt;</code> <var>sock</var> into the
internal ident coserver queue.  When the coserver responds, it runs the
Guile procedure <var>callback</var> as <code>(callback user arg)</code> where
<var>user</var> is the corresponding username for the client connection
<var>sock</var>.  The <var>arg</var> argument is optional. 
</p></blockquote></div>

<div class="node">
<a name="Configuring-servers"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Writing-servers">Writing servers</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Server">Server</a>

</div>

<h3 class="section">8.3 Some words about server configuration</h3>

<p>If you define a server you basically pass an instance name and a list of
items to the <code>(define-server!)</code> function. Each item has a name and a
value. A value has a type. We provide several types: integers (numbers),
integer arrays, strings, string arrays, booleans (yes/no-values), hashes
(associations) and port configurations.

   <p>The following table shows how each kind of value is set up in the
configuration file. <var>item</var> is the name of the item to be configured.

     <dl>
<dt>Integer<br><dd>Example: (item . 42)
<br><dt>Integer array<br><dd>Example: (item . (0 1 2 3))
<br><dt>String<br><dd>Example: (item . "a character string")
<br><dt>String array<br><dd>Example: (item . ("abc" "cba" "bca" "acb"))
<br><dt>Boolean<br><dd>A normal boolean in guile is represented by #t or #f. But the configuration
file parser additional understand some bare words and numbers.<br>
Example: (item . #f)
<br><dt>Hash<br><dd>Hash maps associate keys with values. Both must be character strings.<br>
Example: (item . (key1 . "value1") (key2 . "value2"))
<br><dt>Port configuration<br><dd>See <a href="#Define-ports">Define ports</a>, for more information on this. When configuring a port
configuration you need to define it via <code>(define-port!)</code> previously and
put its symbolic name into the configuration.<br>
Example: (item . foo-tcp-port)
</dl>

<div class="node">
<a name="Coserver"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Bibliography">Bibliography</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Server">Server</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">9 Coserver</h2>

<ul class="menu">
<li><a accesskey="1" href="#What-are-coservers">What are coservers</a>:           The use of coservers in Serveez
<li><a accesskey="2" href="#Existing-coservers">Existing coservers</a>:           What kind of coservers already exist ? 
</ul>

<div class="node">
<a name="What-are-coservers"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Existing-coservers">Existing coservers</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Coserver">Coserver</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Coserver">Coserver</a>

</div>

<h3 class="section">9.1 What are coservers</h3>

<p>If it is necessary to complete blocking tasks in Serveez you have to use
coservers.  Serveez comes with three useful coservers.  Using these
coservers keeps a these blocking tasks from hanging the server.

<div class="node">
<a name="Existing-coservers"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#What-are-coservers">What are coservers</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Coserver">Coserver</a>

</div>

<h3 class="section">9.2 Existing coservers</h3>

<h4 class="subsection">9.2.1 Identification (Ident) coserver</h4>

<p>The Identification protocol is briefly documented in RFC1413. It
provides a means to determine the identity of a user of a particular
TCP connection. Given a TCP port number pair, it returns a character
string which identifies the owner of that connection on the server's
(that is the client's) system.

   <p>This is a connection based application on TCP. A server listens for
TCP connections on TCP port 113 (decimal). Once a connection is
established, the server reads a line of data which specifies the
connection of interest. If it exists, the system dependent user
identifier of the connection of interest is sent as the reply. The
server may then either shut down the connection or it may continue to
read/respond to more queries.

   <p>The Ident coserver is a client to this kind of service. For every
established network connection you can use this service by calling the
appropriate procedure <code>svz:coserver:ident</code> with an appropriate
callback function.

<pre class="example">     (svz:coserver:ident sock my-callback arg)
</pre>
   <p>In this context <code>sock</code> is of type <code>#&lt;svz-socket&gt;</code> and
<code>my-callback</code> is something like the following example. <code>arg</code> is
any Guile value and it gets passed verbatim to the callback procedure. 
A simple callback procedure that just prints out the user could look
something like the following.

<pre class="lisp">     (define (my-callback user args)
       (format #t "Identified user ~a~%" user))
</pre>
   <h4 class="subsection">9.2.2 Domain Name Server (DNS) coserver</h4>

<p>The DNS coserver uses <code>gethostbyname</code> to translate a given
hostname to the associated IP address. It is passed a hostname and,
when it has received a response from the Domain Name Server identifying
the hostname, it calls a callback function to return the internet
address corresponding to that hostname.

<pre class="example">     (svz:coserver:dns "www.gnu.org" coserver-callback args)
</pre>
   <p>Callback:
<pre class="example">     (define (coserver-callback ip args)
       (format #t "The ip address is ~a~%" ip))
</pre>
   <h4 class="subsection">9.2.3 Reverse Domain Name Server (reverse DNS) coserver</h4>

<p>As easily guessed from the name this coserver is just doing the reverse
as the DNS coserver. It translates a given IP address into a hostname
using <code>gethostbyaddr</code>. In the procedure call, the IP address is
given as a positive integer in host byte order. The Reverse DNS coserver
itself takes something like &lsquo;<samp><span class="samp">192.168.2.1</span></samp>&rsquo;.

<pre class="example">     (svz:coserver:reverse-dns (inet-pton AF_INET "192.168.1.255")
       reverse-callback args)
</pre>
   <p>Callback:
<pre class="example">     (define (reverse-callback hostname args)
       (format #t "Hostname is ~a~%" hostname))
</pre>
   <div class="node">
<a name="Bibliography"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#License">License</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Coserver">Coserver</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">10 Bibliography</h2>

<p>This section contain some of the documents and resources we read and used
to implement various parts of this package. They appear in no specific
order.

     <ol type=1 start=1>
<li>RFC 760<br>
The Internet Protocol
<li>RFC 1071<br>
Computing the Internet Checksum
<li>RFC 1413<br>
Identification Protocol
<li>RFC 1459<br>
Internet Relay Chat Protocol
<li>RFC 1945<br>
Hypertext Transfer Protocol &ndash; HTTP/1.0
<li>RFC 2068<br>
Hypertext Transfer Protocol &ndash; HTTP/1.1
<li>RFC 2616<br>
Hypertext Transfer Protocol &ndash; HTTP/1.1
<li>RFC 768<br>
User Datagram Protocol
<li>RFC 791<br>
Internet Protocol
        </ol>

<div class="node">
<a name="License"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Bibliography">Bibliography</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">11 License</h2>

<p>GNU General Public License Version 2, June 1991<br>

   <p>Serveez is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or any later version.

   <p>This software is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

   <p>You should have received a copy of the GNU General Public License
along with this package; see the file COPYING.  If not, write to
the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.

   <p><br>
Copyright &copy; 2010, 2011 Michael Gran &lt;spk121@yahoo.com&gt;<br>
Copyright &copy; 1999, 2000, 2001, 2002 Martin Grabmueller &lt;mgrabmue@cs.tu-berlin.de&gt;<br>
Copyright &copy; 2000, 2001, 2002 Raimund Jacob &lt;raimi@lkcc.org&gt;<br>
Copyright &copy; 2000, 2001, 2002, 2003, 2004 Stefan Jahn &lt;stefan@lkcc.org&gt;<br>

   <p>Verbatim copying and distribution of this entire document is
permitted in any medium, provided this notice is preserved.

   <div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Top" href="#Top">Serveez-MG</a>
<li><a name="toc_Preface" href="#Preface">1 Preface</a>
<li><a name="toc_Introduction" href="#Introduction">2 Introduction</a>
<li><a name="toc_Installation" href="#Installation">3 Installation</a>
<ul>
<li><a href="#Installation">3.1 Install Dependencies</a>
<li><a href="#Installation">3.2 Getting Serveez-MG</a>
<li><a href="#Installation">3.3 Building and Installation</a>
<li><a href="#Installation">3.4 Testing</a>
</li></ul>
<li><a name="toc_Running-and-Managing" href="#Running-and-Managing">4 Running and Managing</a>
<ul>
<li><a href="#Running-and-Managing">4.1 Configuration is Code</a>
<li><a href="#Running-and-Managing">4.2 Trying Serveez</a>
</li></ul>
<li><a name="toc_An-example-Guile-server" href="#An-example-Guile-server">5 An example Guile server</a>
<ul>
<li><a href="#The-HELLO-protocol">5.1 The &ldquo;hello&rdquo; protocol</a>
<li><a href="#The-hello-world-server">5.2 The &ldquo;hello world&rdquo; server</a>
<ul>
<li><a href="#The-callback-functions">5.2.1 The callback functions</a>
</li></ul>
</li></ul>
<li><a name="toc_Deploying" href="#Deploying">6 Deploying</a>
<ul>
<li><a href="#Deploying">6.1 Command line options</a>
<li><a href="#Serveez-Configuration-Concepts">6.2 Serveez Configuration Concepts</a>
<ul>
<li><a href="#Define-ports">6.2.1 Define ports</a>
<ul>
<li><a href="#Define-ports">6.2.1.1 Port configuration items</a>
<li><a href="#Define-ports">6.2.1.2 TCP port definition</a>
<li><a href="#Define-ports">6.2.1.3 Pipe port definition</a>
<li><a href="#Define-ports">6.2.1.4 UDP port definition</a>
</li></ul>
<li><a href="#Define-servers">6.2.2 Define servers</a>
<li><a href="#Bind-servers-to-ports">6.2.3 Bind servers to ports</a>
</li></ul>
<li><a href="#Configuring-the-HTTP-Server">6.3 Configuring the HTTP Server</a>
<ul>
<li><a href="#Configuring-the-HTTP-Server">6.3.1 Configuration</a>
</li></ul>
<li><a href="#Setup-the-Control-Protocol-Server">6.4 Setup the Control Protocol Server</a>
<ul>
<li><a href="#Setup-the-Control-Protocol-Server">6.4.1 Configuration of the Control Protocol Server</a>
<li><a href="#Setup-the-Control-Protocol-Server">6.4.2 Using the Control Protocol</a>
</li></ul>
<li><a href="#Setup-the-Control-Protocol-Server">6.5 Additional configuration possibilities</a>
<ul>
<li><a href="#Setup-the-Control-Protocol-Server">6.5.1 Passthrough Server</a>
<ul>
<li><a href="#Setup-the-Control-Protocol-Server">6.5.1.1 General description</a>
<li><a href="#Setup-the-Control-Protocol-Server">6.5.1.2 Configuration</a>
</li></ul>
</li></ul>
</li></ul>
<li><a name="toc_Concept" href="#Concept">7 Concept</a>
<ul>
<li><a href="#Concept">7.1 Overall concept</a>
<li><a href="#Concept">7.2 I/O Strategy</a>
<ul>
<li><a href="#Concept">7.2.1 Limits on open filehandles</a>
</li></ul>
</li></ul>
<li><a name="toc_Server" href="#Server">8 Server</a>
<ul>
<li><a href="#Introduction-to-servers">8.1 Introduction to servers</a>
<li><a href="#Writing-servers">8.2 Writing servers in Guile</a>
<ul>
<li><a href="#Guile-servers">8.2.1 Guile server functions reference manual</a>
<ul>
<li><a href="#Guile-servers">8.2.1.1 Special Data Types</a>
<li><a href="#Guile-servers">8.2.1.2 Passing Binary Data</a>
<li><a href="#Guile-servers">8.2.1.3 Server Definition</a>
<li><a href="#Guile-servers">8.2.1.4 Callback Prototypes</a>
<li><a href="#Guile-servers">8.2.1.5 Predefined Procedures</a>
</li></ul>
</li></ul>
<li><a href="#Configuring-servers">8.3 Some words about server configuration</a>
</li></ul>
<li><a name="toc_Coserver" href="#Coserver">9 Coserver</a>
<ul>
<li><a href="#What-are-coservers">9.1 What are coservers</a>
<li><a href="#Existing-coservers">9.2 Existing coservers</a>
<ul>
<li><a href="#Existing-coservers">9.2.1 Identification (Ident) coserver</a>
<li><a href="#Existing-coservers">9.2.2 Domain Name Server (DNS) coserver</a>
<li><a href="#Existing-coservers">9.2.3 Reverse Domain Name Server (reverse DNS) coserver</a>
</li></ul>
</li></ul>
<li><a name="toc_Bibliography" href="#Bibliography">10 Bibliography</a>
<li><a name="toc_License" href="#License">11 License</a>
</li></ul>
</div>

</body></html>

